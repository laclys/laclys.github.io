[{"title":"记一次pnpm monorepo实践","date":"2023-12-09T14:02:15.962Z","path":"2023/12/09/记一次pnpm monorepo实践/","text":"入职新公司快一个月了。再一次的东京生活也算稳定下来了。到现在为止生活还算惬意，30 岁之后心态真的会发生很大的变化（笑 每当天气好的清晨黄昏，就可以在小屋阳台看到富士山 话不多说，接手的第一个项目是类似问卷的项目，包括管理侧制作问卷，和用户侧使用问卷。分两个仓库开发过一版，但是种种原因没有上线。现在时机成熟了，重启项目。新的一版设计中管理侧有预览用户侧问卷的功能，那为什么不把两个仓库合二为一呢。 上一份工作有大规模的使用 Monorepo，采用的是微软开源的NX作为构建 Monorepo 的方案，功能很齐全很强大，它的命令行工具类似 NG CLI，但这样带来的副作用就是刚上手可能会有一些不知所措。小型项目使用的话，有些杀鸡用牛刀。短暂的考虑一番之后，决定采用简单轻量pnpm workspace方案，花了一天时间把两个项目合而为一，顺便替换掉Yarn. 由于基于原 admin 仓库进行改造的，在项目根目录创建pnpm-workspace.yaml文件，确定 workspace 位置。我这边的初步设计很简单就是 两个 App 分别是: admin 和 user，公共部分放在 packages 文件夹里项目结构如下 1234567.├── apps│ │ ├── admin (Admin app)│ │ ├── user (User app)├── packages (Common) 仅此pnpm-workspace.yaml配置如下(暴露了两个文件夹) 123packages: - &#x27;packages/*&#x27; - &#x27;apps/*&#x27; 三部分就是三个独立的前端项目。 之前 admin 代码内容统统移动到 apps&#x2F;admin 里面。合并的 user 仓库代码夜一并移动到 apps&#x2F;user 中。公共部分 packages 和最外层 也pnpm init分别创建package.json。 调整package.json中 name（也就是包名）现在四个 workspace 区域。最好起名相互管理。这里最外层叫lacApp,里层三个项目分别交@lacApp/admin&#x2F;@lacApp/user以及@lacApp/packages 删除调整代码：之前移动过去的 admin、user 代码。删除 lock file，ignore file（之后在外层统一管理）。.eslintrc&#x2F;tsconfig如果用共同，推荐在外层维护一个共通的配置，里层项目通过 extend 方式继承调整配置代码 4.公共部分 npm 包移动到最外层。比如react&#x2F;eslint&#x2F;axios&#x2F;vite&#x2F;typescript··这些两个 app 或者公共包都会用的移动到最外层，相应的里层package.json中进行删除。 如果之后需要全局安装以来，可以通过 -w、–workspace-root 参数来安装. 给某个特定的 package 安装依赖，可以通过 –filter 参数来安装. eg： 12345# 全局安装开发依赖eslintpnpm install eslint -wD# 特定的 package 安装依赖pnpm add dayjs --filter @lacApp/admin 模块之间进行相互依赖，比如我们的公共部分@lacApp/packages，分别在 admin 和 user 中使用。它作为一个包,作为 app 的依赖 1pnpm add @lacApp/packages -r --filter @lacApp/admin 4.调整好后，最外层添加 file：.npmrc 1auto-install-peers = true 告诉npm在安装一个包的同时，自动安装其在 monorepo 中的相互依赖（peer dependencies）。 5.最外层pnpm i 就可以了。（是不是很简单，在外层生成一份 lock 文件。并且里层的 npm 包也一并进行了安装 6.调整 script。其实 cd 到里层项目执行脚本完全 ok。但是这里更推荐。外层去配置相应的 script 统一管理 比如： 123### devpnpm -r --filter=@lacApp/admin run devpnpm -r --filter=@lacApp/user run dev 12###如果想要一起执行也是可以的（默认情况下，pnpm 会根据子包的依赖拓扑排序，按顺序对子包执行命令，以避免在构建某个包的时候，出现子依赖的构建产物未生成的问题，进而引发比如类型错误等问题。另外如果两个子包没有依赖关系，pnpm 会并发进行构建。pnpm -r --filter=./apps/* run dev 7.其实到这一步就算完了，是不是很简单。构建配置需要和运维进行简单的沟通。可能之前 dist 目录在根目录现在无非在 apps/admin/dist和 apps/user/dist多了两层 8.* 上车turborepo.其实其实到第七步就算完了，是不是很简单。为了更好的 monorepo 构建体验（想折腾一下）可以上车Turborepo. turborepo 是一个适用于 JavaScript 和 Typescript monorepo 的高性能构建工具，它不是一个侵入式的工具，你可以在项目中渐进的引入和使用它，它通过足够的封装度，使用一些简单的配置来达到高性能的项目构建。和 esbuild 一样，Turborepo 也是基于 go&#x2F;rust 实现的工具，在语言层面上就具有一定的性能优势。还有更快的增量构建。turborepo 中的缓存机制 可以帮助我们记住构建内容 并且跳过已经计算过的内容，优化打包效率。（真的超级快 https://turbo.build/repo turborepo 正因为它可以渐进的引入和使用，改造起来很简单。 1pnpm install turbo -w -D 之后在根目录配置 turbo.json.这里有个pipeline 管道的概念， 说简单点就是基于turbo.json约定的配置，控制脚本执行的顺序、依赖。按配置文件定义任务之间的关系，然后让 Turborepo 优化构建内容和时间 在我们执行turbo run命令的时候turbo会根据我们定义的 Pipelines(https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks) 里对命令的各种配置去对我们的每个 package 中的 package.json 中 对应的 script 执行脚本进行有序的执行和缓存输出的文件。 当然 turbo 里的 pipeline name 也是 monorepo 中每一个子包里的script。比如 admin app 和 user app 都有run dev命令。这里就可以定义一个 name 为 dev 的 Pipelines.执行 script：turbo run dev就会同时执行 两个 app 中定义的dev命令 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;$schema&quot;: &quot;https://turbo.build/schema.json&quot;, &quot;pipeline&quot;: &#123; &quot;build&quot;: &#123; // A workspace&#x27;s `build` task depends on that workspace&#x27;s // topological dependencies&#x27; and devDependencies&#x27; // `build` tasks being completed first. The `^` symbol // indicates an upstream dependency. // 可以通过^符号来显式声明该任务具有拓扑依赖性，需要依赖的包执行完相应的任务后才能开始执行自己的任务 // 比如我们的admin项目引用了@lacApp/package.便构成了依赖关系，根据build的dependsOn配置， // 会先执行依赖项的build命令，也就是@lacApp/package.的build命令，依赖项执行完后才会执行@lacApp/package的build命令。 // 如果我们不添加&quot;dependsOn&quot;: [&quot;^build&quot;]数组中的‘^’那么就代表我们当前只需要执行我们自己的build命令 &quot;dependsOn&quot;: [&quot;^build&quot;], &quot;outputs&quot;: [&quot;.next/**&quot;, &quot;!.next/cache/**&quot;, &quot;.svelte-kit/**&quot;] &#125;, &quot;deploy&quot;: &#123; // A workspace&#x27;s `deploy` task depends on the `build`, // `test`, and `lint` tasks of the same workspace // being completed. // 如果一个任务的执行，只依赖自己包其他的任务，那么可以把依赖的任务放在dependsOn数组里 &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;] &#125;, &quot;test&quot;: &#123; // A workspace&#x27;s `test` task depends on that workspace&#x27;s // own `build` task being completed first. &quot;dependsOn&quot;: [&quot;build&quot;], // A workspace&#x27;s `test` task should only be rerun when // either a `.tsx` or `.ts` file has changed. &quot;inputs&quot;: [&quot;src/**/*.tsx&quot;, &quot;src/**/*.ts&quot;, &quot;test/**/*.ts&quot;, &quot;test/**/*.tsx&quot;] &#125;, // A workspace&#x27;s `lint` task has no dependencies and // can be run whenever. // 如果一个任务的dependsOn为[] 或者不声明这个属性，那么表明这个任务可以在任意时间被执行 &quot;lint&quot;: &#123;&#125;, // 这里 dev。我们当然希望它不做任何缓存 &quot;dev&quot;: &#123; &quot;cache&quot;: false, // Label a task as persistent if it is a long-running process, such as a dev server or --watch mode. Turbo will prevent other tasks from depending on persistent tasks. Without setting this config, if any other task depends on dev, it will never run, because dev never exits. With this option, turbo can warn you about an invalid configuration. &quot;persistent&quot;: true &#125; &#125;&#125; 最后还要提一下 filter 过滤语法 其实和 pnpm 的类似 比如我们只想用 turbo build admin 项目 。我们就可以 1build:admin&quot;: &quot;turbo run build --filter=@lacApp/admin&quot;, 加上 Turbo，可以在已经很快的构建上，锦上添花。 就这样吧","tags":[{"name":"pnpm","slug":"pnpm","permalink":"http://yoursite.com/tags/pnpm/"},{"name":"monorepo","slug":"monorepo","permalink":"http://yoursite.com/tags/monorepo/"}]},{"title":"gap这小半年","date":"2023-10-12T11:25:55.283Z","path":"2023/10/12/gap这小半年/","text":"要开始下一程了，在这个没人在意的角落。记录一下这为期半年的Gap，踏入社会之后难得的长假。 新加坡前司Last Day是今年三月的的最后一天，各种手续办完，和同事简单寒暄之后大概下午四五点的样子。离开了公司。删除Lark那一刻，紧绷两年的神经一下子松了下来。 自己是一个特别容易焦虑的人，生活上、工作上都是。无论是否工作日，睡前、起床第一眼都是公司的SNS，看看有没有漏掉的消息，负责的系统是否平稳运行。神经总是紧绷的。 为什么离职呢？工作方面，前司除了忙，什么都好。薪资在坡很有竞争力，可以WFH，只是必须在新加坡（这样也很舒服），Office呢有星巴克咖啡机，各种零食、冷饮。当年晚上七点Garb外卖随便点。托公司投资的福，在很好的位置观看了F1新加坡站的比赛(P房正对面座位) （F1·Singapore） 但就是出在“忙”这一块。晚上十点下班是家常便饭，周末也得不到休息。这样长期下来很不好，更甚的是时常陷入疲惫、空虚、自我价值的怀疑的旋涡。 感觉在瞎忙一通。管理层对市场的错误判断导致：在牛市疯狂招人，热度褪去又大幅度裁人。去年就经历了两次这样的事情（年中一次，年底一次）。 业务方面总是比友商慢半拍，管理层很着急。为了抓住市场东一榔头西一棒槌的“快速试错”。 当然我们就成为了试错的工具，上游没有底，更何况作为执行层的产品和开发。这样设计出来的东西可想而知，产品设计的太复杂，用户看不懂，UI呢也和其他项目没有一致性。当然自己作为开发保证的是自己负责的项目不出错，稳定的运行。但在这么赶的时间上线，心理不犯怵那是不可能的。 扯了这么多，去年底那一波大裁员之后，自己有了离开的想法。当然还有一个原因：自己和老婆并不怎么喜欢新加坡。每一天都是潮湿炎热的夏天，像是诅咒一遍永无止境的轮回，无论是7月还是12月。同时也感受不到时间的流逝，在生活一年之后让自己非常思念四季。生命当中应该有四季！！ 另外还有无趣的文化生活，新加坡居民的假期：去水库徒步，去马来西亚新山吃同样但便宜的食物。（总不能天天出国） 最后就是高的离谱的物价、房租（自己做之前一个OneRoom 小公寓已经涨到了3000新币一个月，还不包括水电网。如果日后长久居住买房投资好像也不是那么好（自己也没有成为公民的打算，但坡政府在各种利益细节上让你觉得PR好吃亏） 当然以上内容皆为我主观感受！ 在剩下的日子和几个要好的前同事朋友吃了几顿饭，为新加坡生活收尾。四月底飞机回到了阔别两年的国内！ 国内回国之后，工作的事暂时不去想。计划也是如此等7月份再说。这两年国内过得很难，但依旧出来了很多新的“好吃、好喝”。和老婆去了云南（元阳、腾冲、芒市），在长沙去各种湘菜馆打卡，也在长沙买了房子。西安呢，爸妈带着各种吃好吃的，逛了很多之前没去过的寺庙，新开的考古博物馆也别不错。家门口大唐不夜城总感觉比疫情前人更多了。当然还久违的体验了一把火车进藏，去拉萨玩了一圈。 (元阳·阿者科) (林芝·色林错) 回来就开始准备找工作，想着一鼓作气日本、国内的都在投。国内也只考虑外企实在不想卷了。下面是之前总结的时间线，懒得编辑就直接放在下面了。 找工作时间线6月中旬 开始整理简历。和猎头沟通交流情况(是一个挪威小哥，事无巨细真的超负责。真的很感谢） 6月下旬 简历投递，等待书面选考(这个过程通常要等很久，在期间跑去西藏玩了一圈） 7月中旬 集中面试 &#x2F; 期间也投了几家国内外企（不想再卷了） 07&#x2F;28 拿到内定 08&#x2F;03 Offer细节、不明点沟通、拉扯 08&#x2F;04 接受Offer，拒绝手头上其他Offer，和进行中的流程 由于满足高才标准, 公司协助申请高才。 整理准备材料（最前面两端工作经历太久远了，没有提供证明文件。不过80分以上就好） 由公司的行政书士协助Review、调整、初审核材料 (没想到这一步，等了好久。中间正好赶上日本盂兰盆节) 08&#x2F;29 入国管理局へ提出(这时候已经麻了) 09&#x2F;13 在留下来 (12个工作日) 09&#x2F;19 收到在留 09&#x2F;20 机构提交材料 办理签证(又赶上十一国庆） 期间 公司人事协助联系租房中介介绍房源 10&#x2F;07 大使馆出签 10&#x2F;08 收到签证(去年底才办的五年旅游签用了一次就Cancel,还是有点难受) 10&#x2F;10 回复公司人事，确定赶日时间（10&#x2F;20 西安飞东京） 这次最意外，超出预期就是拿到Offer之后，没想到等了这么久。（据说技术·人文更慢,高度人才优先审批) 不过好使多磨嘛，兜兜转转又要回日本了！ 以上~","tags":[{"name":"杂","slug":"杂","permalink":"http://yoursite.com/tags/%E6%9D%82/"},{"name":"日本","slug":"日本","permalink":"http://yoursite.com/tags/%E6%97%A5%E6%9C%AC/"},{"name":"Gap","slug":"Gap","permalink":"http://yoursite.com/tags/Gap/"},{"name":"新加坡","slug":"新加坡","permalink":"http://yoursite.com/tags/%E6%96%B0%E5%8A%A0%E5%9D%A1/"}]},{"title":"CSS技术笔记","date":"2023-09-23T07:45:47.311Z","path":"2023/09/23/CSS技术笔记/","text":"转眼就要 10 月了，依旧赋闲在家。8 月份确定 Offer 以来，心安了很多(后续会列举出完整的时间线)。 这次的就活顺利结束，接着休息、看技术、学日语。等待出发。 林芝·雅鲁藏布江大峡谷 下面是掘金CSS 技术揭秘与实战通关这本小册的一些 Note。相当用心的一本小册(可以说开了眼界，学到了很多) 今年以来唯二值得推荐的掘金小册，link：https://juejin.cn/book/7052964245259943948 整个学习过程一部分手敲联系代码放到了这里一共114 case (不单单是小册里面的 CSS 技巧还有一些其他尝试) Repo: https://github.com/laclys/css-practice-2023 下面呢就是 Note 部分 社区好用的 clip-path 工具: https://bennettfeely.com/clippy/ https://codepen.io/stoumann/pen/abZxoOM clip-path 局限性：使用 clip-path 生成图形的非常大一个问题在于，它无法作用完整的边框 利用阴影实现任意图片的转换使用阴影 box-shadow 可以实现自我复制box-shadow 具有多重性，也就是不论层数有多少都可以。因此，理论上任何一张图片的每个像素点都可以用一个 1px*1px 的 box-shadow 来表示 我们可以借助 Canvas 提供的 CanvasRenderingContext2D.getImageData 方法，它可以获取图片的每个像素点的 RGBA 值。因此，将一张图片转换为完全由 box-shadow 表示的图片是完全可行的 demo: http://chokcoco.github.io/demo/img2div/html/ 滤镜 filter 通过 CSS 的 filter 属性，使用滤镜； 通过 CSS 的 backdrop-filter 属性，使用滤镜； 通过 CSS filter 属性中的 url() 值，引入由 SVG 实现的特殊滤镜效果。 12345678910111213141516171819202122232425 &#123; // 模糊滤镜 filter: blur(5px); // 明亮度滤镜 filter: brightness(0.4); // 对比度滤镜 filter: contrast(200%); // 阴影滤镜 filter: drop-shadow(16px 16px 20px blue); // 灰度滤镜 filter: grayscale(50%); // 色相旋转滤镜 filter: hue-rotate(90deg); // 反转滤镜 filter: invert(75%); // 不透明度滤镜 filter: opacity(25%); // 饱和度滤镜 filter: saturate(30%); // 褐色滤镜 filter: sepia(60%); /* 滤镜可以叠加 */ filter: contrast(175%) brightness(3%);&#125; filter 与 backdrop-filter 的异同 filter：模糊滤镜的作用是将模糊或颜色偏移等图形效果作用于元素之上。 backdrop-filter：该属性可以在元素后方区域，添加上模糊或颜色偏移等图形效果。 backdrop-filter 的生效范围是元素背后的所有内容，因此，为了能够看到效果，元素或其背景至少要保持部分透明(这个区域是可以移动的)。 !的作用元素上的差异! filter 与 backdrop-filter 问题 作用了 filter 和 backdrop-filter 的元素会导致 3D 效果失效 用了 filter 和 backdrop-filter 的元素会使内部的 fixed 定位失效 drop-shadow 与 box-shadow 的异同 box-shadow 属性在元素的整个框后面创建一个矩形阴影； drop-shadow() 滤镜用于创建一个符合元素（图像）本身形状（alpha 通道）的阴影 box-shadow 有内阴影，内阴影使用关键字 inset 进行描述，而 drop-shadow 是没有内阴影的； box-shadow 多一个阴影扩散半径参数，drop-shadow 是没有阴影扩散半径参数的。 设置了 drop-shadow() 的元素，它不单单是针对自身元素，还会向下寻找所有子元素的形状（alpha 通道），对其设置阴影 box-shadow 只作用于自身 insetinset属性用作定位元素的 top、right、bottom、left 这些属性的简写。类似于 margin 和 padding 属性，依照“上右下左”的顺序 12345678inset: 0;/* 等同于 `top: 0; right: 0; bottom: 0; left: 0;` */inset: 1px 2px;/* 等同于 `top: 1px; right: 2px; bottom: 1px; left: 2px;` */inset: 1px 2px 3px;/* 等同于 `top: 1px; right: 2px; bottom: 3px; left: 2px;` */inset: 1px 2px 3px 4px;/* 等同于 `top: 1px; right: 2px; bottom: 3px; left: 4px;` */ inset 属性只作用于定位元素。Internet Explorer 浏览器上不支持该属性！！！ filter: opacity 与 opacity用法一致 1234567div &#123; filter: opacity(35%);&#125;// ORdiv &#123; opacity: 0.35;&#125; filter 滤镜会导致 3D 失效和 position: fixed 定位失效，这个属于所有滤镜的特性。opacity 则不会 使用 filter: opacity 能够更好地获得浏览器提供的硬件加速支持，也就是获得更好的性能。从层叠上下文和包含块的角度而言，filter: opacity 和 opacity 都会生成一个新的层叠上下文，但是只有 filter: opacity 会生成包含块（Containing Block）。当然，对于现代浏览器，这两者的性能差异，几乎可以忽略。 混合模式 mix-blend-mode background-blend-mode 混合模式用于创建两个或多个元素之间互相混合的效果。可以将混合模式应用于元素、背景图片和边框等任何元素。 什么时候使用混合模式: 元素&#x2F;图片，在色彩方面遇到了一些问题（与色彩打交道），譬如透明遮罩、颜色翻转、反相、变暗、重叠展示等场景，就应该想到，可能可以利用混合模式来解决问题！ 混合模式也会导致 3D 效果失效!!! 混合模式的核心就是：描述当元素重叠时，颜色应当如何呈现。 没有伪元素的元素诸如 &lt;img&gt; 、 &lt;input&gt;、 &lt;iframe&gt;，这几个标签是不支持类似 input::before 这种使用方式的 当 img 元素的 src 地址能够正常指向一个图片资源的时候， &lt;img&gt; 的 ::before 和 ::after 确实是不会生效的。但是，如果 src 指向的是一个错误的地址，也就是图片无法正常被解析替换，在这种特殊的情况下，大部分现代浏览器是支持这种状态下的元素能够有自己的伪元素 ::before 和 ::after 的 CSS 过渡 可以通过关键字 all 给所有属性设置过渡； transition 支持多个属性的精细化控制； 过渡效果支持延迟加载；（https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties）transition-duration 0 与非 0 切换的效果可以变相实现画板，刮刮乐效果 background 99999999s）(当我们的鼠标想去到菜单界面的时候，由于我们的鼠标离开了按钮区域，导致出现了的菜单又消失不见,可以加加入 transition-duration) 并非所有元素都是支持过渡动画的。 animation 必须项：animation-name、animation-duration 和 @keyframes 规则。 非必须项：animation-delay、animation-direction、animation-iteration-count、animation-play-state、animation-timing-function、animation-fill-mode、animation-composition，当然不是说它们不重要，只是不设置时，它们都有默认值。 animation-delay 的值可以为负值 12345animation-timing-function: ease; // 动画以低速开始，然后加快，在结束前变慢animation-timing-function: ease-in; // 动画以低速开始animation-timing-function: ease-out; // 动画以低速结束animation-timing-function: ease-in-out; // 动画以低速开始和结束animation-timing-function: linear; // 匀速，动画从头到尾的速度是相同的 CSS 自定义属性的传值方式 通过 CSS 代码进行 CSS 变量值的传递； 通过元素的 style 属性进行 CSS 变量值的传递； 通过 JavaScript 改写 style 属性进行 CSS 变量值的传递 !!!calc 的没有字符串拼接的能力!!!! CSS @property syntax：该自定义属性的语法规则，也可以理解为表示定义的自定义属性的类型。 inherits：是否允许继承。 initial-value：初始值。 @property 规则中的 syntax 和 inherits 描述符是必需的 syntax 支持字段： 123456789101112131415lengthnumberpercentagelength-percentagecolorimageurlintegerangletimeresolutiontransform-listtransform-functioncustom-ident (a custom identifier string) CSS 自定义属性的作用及意义 代码更加符合 DRY（Don‘t repeat yourself）原则，精简代码，减少冗余 CSS @property 解决了大量过往无法实现动画&#x2F;过渡的交互场景。 方便地从 JS 中读&#x2F;写，统一修改，增强了 JavaScript 与 CSS 的联系。 calc() 运算函数 + 和 - 运算符的两边必须要有空白字符。比如，calc(50% -8px) 会被解析成为一个无效的表达式，必须写成calc(8px + -50%)。 calc() 支持与 CSS 变量混合使用 可以嵌套使用 123&#123; width: calc(100vw - calc(100% - 64px));&#125; calc 没有字符串拼接的能力(唯一可能完成字符串拼接的是在元素的伪元素的 content 属性) min()、max()、clamp() 比较函数 max()：从一个逗号分隔的表达式列表中选择最大（正方向）的值作为属性的值。 min()：从一个逗号分隔的表达式列表中选择最小的值作为属性的值。 clamp()：把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。 比较函数配合 calc() 一起使用 eg: 123div &#123; width: max(50vw, calc(300px + 10%));&#125; clamp() 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。clamp(MIN, VAL, MAX) 其实就是表示 max(MIN, min(VAL, MAX)) 可以使用 vw 配合 clamp 实现响应式布局 在移动端适配，我们更为推崇的是 vw 纯 CSS 方案，与 rem 方案类似，它的本质也是页面的等比例缩放。它的一个问题在于，如果仅仅使用 vw，随着屏幕的不断变大或者缩小，内容元素将会一直变大变小下去，这也导致了在大屏幕下，许多元素看着实在太大了！ font-size: clamp(12px, 3.75vw, 20px)，就能将字体限制在 12px - 20px 的范围内 (没有额外 JavaScript 代码的引入，纯 CSS 解决方案；能够很好地控制边界阈值，合理地进行缩放展示，避免传统的老人机现象（部分场景下字体过大）。) Layout margin: auto 在垂直方向上能够居中元素，需要让该元素处于 FFC（flex formatting context），或者 GFC（grid formatting context）上下文中 可以利用 display: flex 等 flex、 grid 布局上下文下，利用 margin: auto 实现元素的水平垂直居中 eg: 123&lt;div class=&quot;g-container&quot;&gt; &lt;div class=&quot;g-box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567.g-container &#123; display: flex;&#125;.g-box &#123; margin: auto;&#125; 在通过 justify-content 和align-self进行对齐之前，任何正处于空闲的空间都会分配到该维度中的自动 margin 中去 Note: If free space is distributed to auto margins, the alignment properties will have no effect in that dimension because the margins will have stolen all the free space left over after flexing. 块格式化上下文中 margin-top 和 margin-bottom 的值如果是 auto，则它们的值都为 0。 flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。 单个方向上的自动 margin 也非常有用，它的计算值为该方向上的剩余空间。 使用了自动 margin 的 flex 子项目，它们父元素设置的 justify-content 以及它们本身的 align-self 将不再生效。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"记一次Hexo博客404问题排查","date":"2022-12-26T07:47:20.338Z","path":"2022/12/26/记一次Hexo博客404问题排查/","text":"这一整年工作一直很忙，github&#x2F;博客一直没有更新、搭理。前段时间整理产出了一篇工作上的积累 项目图片优化使用WEBP 像往常一样 hexo g &amp; hexo d 一条龙生成+部署，就没有管它。 最近重新拾起，访问了一下blog，发现居然是空白页。刷新了数次、使用无痕再重新hexo g &amp; hexo d，还是空白。这是怎么回事呢，意味着上次更新完博客，一直处于“挂了“的状态 排查&amp;定位 访问https://laclys.github.io/ 空白打开控制台，很容易发现 index.html 是空的 然后在本地重新hexo g(hexo generate) 查看 public文件夹下生成的html，发现都是空文件，0 bytes。问题找到了 generate 这一步出现了问题。 Hexo这边最近这一年是没有升级的，通过Google大法找到了相关问题的issuehexo generates empty files #4267 简单说就是 本机的hexo版本(3.90)不支持node14.x以上的版本。&#104;&#x65;&#120;&#x6f;&#x40;&#51;&#46;&#x39;&#x2e;&#x30;(现在已经6.3.0), node模糊记忆年中升级过一次 现在是 v14.17.6(其实也算老版本了，现在LTS已经18.12.1) 解决找到问题根因 无非两种方式 一种是降级node版本 还有一种是整体升级 降级Node首先尝试第一种，之前有装过nvm(node版本管理工具)，一键安装切换到 12.14.0 12nvm install 12.14.0nvm use 12.14.0 hexo clean清空之前的生成物，重新 hexo g 再次查看public文件夹生成物： index.html 已经正常生成，hexo d, 再次打开blog 网站恢复 升级Node + Hexo降级方式验证通过，可行 + 简单。再来试一下升级方案 1234### node使用最新稳定版本nvm use 18.12.1### 全局更新一下 hexo-clinpm i hexo-cli -g 升级hexo 升级前： 1npm update 升级后： 1hexo g 一切顺利 生成index.html, hexo d 顺利部署，没有遇到网上说的问题一切顺利~YES","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"项目图片优化：整体替换WEBP","date":"2022-10-09T14:41:26.829Z","path":"2022/10/09/项目图片优化：整体替换WEBP/","text":"具体方案：开发脚本 整体生成 WEBP图片(Eg.: 项目中a.png，再生成一份a.png.webp)Shell脚本(需安装：brew install webp)(https://developers.google.com/speed/webp/docs/cwebp) 1234567891011#!/bin/bash# Usage: ./cwebp.sh &lt;directory&gt;echo &#x27;Converting all .png, .jpg, and .jpeg files to .webp...&#x27;find $1 -type f -and \\( -iname &quot;*.jpg&quot; -o -iname &quot;*.jpeg&quot; -o -iname &quot;*.png&quot; \\) \\-exec bash -c &#x27;if [ ! -f &quot;$0.webp&quot; ]; then cwebp -q 90 -mt -m 6 &quot;$0&quot; -o &quot;$0.webp&quot; 2&gt;/dev/null;fi&#x27; $forced &#123;&#125; \\; 前端项目脚本 1234567891011const &#123; join,resolve &#125; = require(&#x27;path&#x27;)const &#123; execSync &#125; = require(&#x27;child_process&#x27;);const _root = resolve(__dirname, &#x27;..&#x27;)const arg = process.argv[2];if (!!arg) &#123; const targetPath = join(...[_root].concat(arg)) const scriptPath = join(...[_root].concat(&#x27;script/cwebp.sh&#x27;)) execSync(`$&#123;scriptPath&#125; $&#123;targetPath&#125;`, &#123; stdio: [0, 1, 2] &#125;);&#125; Usage: 1&lt;pnpm | npm | yarn&gt; run cwebp &lt;directory&gt; 判断浏览器是否支持WEBP，如支持使用WEBP格式图片，不支持使用原图 (Ref:https://caniuse.com/webp).如支持根节点添加标识: &lt;html class=&quot;webpa&quot;&gt;...&lt;/html&gt;12345const isWebp = document.createElement(&quot;canvas&quot;).toDataURL(&quot;image/webp&quot;).includes(&quot;data:image/webp&quot;);const htmDom = document.documentElement;if(isWebp) &#123; htmDom.classList.add(&quot;webpa&quot;);&#125; css&#x2F;less…样式图片处理以less为例其他样式预处理器同理 123456789101112/* webp mixin */.webpbg(@url) &#123; background-image: url(@url); .webpa &amp; &#123; background-image: url(&#x27;@&#123;url&#125;.webp&#x27;); &#125;&#125;// Usage+ .webpbg(url)- background-image(url) 项目mixin可通过webpack插件：style-resources-loader 统一引入 JSX img标签处理使用 兼容webpEg. 123456789101112131415import React from &#x27;react&#x27;;const Img = (props) =&gt; ( &lt;picture className=&#123;props?.className&#125;&gt; &lt;source className=&#123;props?.className&#125; srcSet=&#123;`$&#123;props?.src&#125;.webp`&#125; type=&quot;image/webp&quot; /&gt; &lt;img className=&#123;props?.className&#125; src=&#123;props?.src&#125; alt=&#123;props?.alt&#125; loading=&quot;lazy&quot; /&gt; &lt;/picture&gt; );export default Img; *并不是一股脑儿把所有图片转化成webp就是最优解，面对线性、矢量、渐变图片转化成svg反而更好。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Docker Note","date":"2021-07-03T17:32:34.158Z","path":"2021/07/04/Docker-Note1/","text":"容器技术的一个实现 container 快速打包技术 标准化 轻量化 易移植 Linux Container(2008) Namespace和Cgroup(负责资源管理控制)两大机制保障 标准化docker != container runtime spec(基本规范 eg：下载、创建容器) image spec(镜像的基本格式) Image VS ContainerImage Docker image是一个 read-only 文件 理解成一个模板 包含文件系统、源码、库文件还有依赖 Image有分层的概念 Container ”运行中的Docker Image“ 实质是复制image并在image最上层加上一层read-write的层 （称之为container layer,容器层） 一个Image可以创建多个Container 获取 自己 从registry拉取(docker hub) basic docker container run nginx可以去创建一个容器，如果没有nginx会去下载 docker container ls容器的列出(up) docker container stop (ID可以只写前面)容器的停止 docker container ps -a or docker container ls -a容器的列出(up和exit)(停止的也会展示) docker container rm 容器的删除 tips docker container stop $(docker container ps -qa)批量停止 docker container ps -qa打印出所有container ID传入$ docker container rm $(docker container ps -qa)同理批量删除 docker container ps -qa打印出所有container ID传入$、 不能直接删除正在运行的容器(先停止再删除或者 加-f强制) 容器两种模式attached和detached模式(win不是完整的attached模式，ctrl+c不能把容器停掉) detached模式 &gt; docker container run -d -p 80:80 nginx (后台运行) docker attach detached -&gt; attached (* 创建容器尽量使用detached模式) 容器交互 docker container logs 查看log docker container logs -f 实时查看log docker container run -it ubuntu sh创建一个容器并进入交互式模式 (这里创建了ubuntu sh) docker container exec -it在一个已经运行的容器里执行一个额外的command eg: 1234docker container run -d -p 80:80 nginxdocker exec -it &lt;ID&gt; sh *exit退出 Container vs VM 容器并不是mini的虚拟机：container其实就是进程。容器中的进程被限制了对CPU内存等资源的访问。当进程停止后，容器就退出 docker container top 显示container运行了那些进程 docker container run 在本地查找是否有nginx这个image镜像，但是没有发现 去远程的image registry查找nginx镜像（默认的registry是Docker Hub) 下载最新版本的nginx镜像 （nginx:latest 默认) 基于nginx镜像来创建一个新的容器，并且准备运行 docker engine分配给这个容器一个虚拟IP地址 在宿主机上打开80端口并把容器的80端口转发到宿主机上 启动容器，运行指定的命令（这里是一个shell脚本去启动nginx） 镜像获取 pull from registry (online) 从registry拉取(dockerhub) public（公有） private（私有） build from Dockerfile (online) 从Dockerfile构建 load from file (offline) 文件导入 （离线）(backup.tar) Image操作 docker image pull xxx拉取镜像xxx docker image pull nginx:1.20.0指定版本 拉取nginx:1.20.0 docker image pull quay.io&#x2F;bitnami&#x2F;nginxQuay上拉取镜像 docker image ls查看镜像 docker image inspect 显示镜像更多信息 docker image rm 删除镜像(如果有正在使用的容器是无法删除的 必须docker container rm 删除了容器才可以) Image导出、导入 docker image save nginx&lt;: version&gt; -o nginx.image导出 docker image load -i .&#x2F;nginx.image导入 Dockerfile Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using docker build users can create an automated build that executes several command-line instructions in succession. 是用于构建docker镜像的文件 里包含了构建镜像所需的“指令” 有其特定的语法规则 examplehello.py 1print(&#x27;hello docker!&#x27;) Dockerfile 12345FROM ubuntu:21.04RUN apt-get update &amp;&amp; \\ DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3.9 python3-pip python3.9-devADD hello.py /CMD [&quot;python3&quot;, &quot;/hello.py&quot;] RUN: 指定镜像被构建时要运行的命令 CMD: 指定容器被启动时要运行的命令 ENTRYPOINT: 同 CMD ，但不会被 docker run -t 覆盖 WORKDIR: CMD&#x2F;ENTRYPOINT 会在这个目录下执行 VOLUME ADD COPY docker image build -t hello .构建名为hello的构建(-t是tag的意思) 123➜ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEhello latest 1a963417de9a 43 seconds ago 206MB 构建成功 12➜ docker run -it hellohello docker! 执行成功！ commitdocker提供了一个方法直接 通过一个container创建一个新的image docker container commit REPOSITORY:[:tag] 前端example 新建一个文件夹 docker 创建dockerfile &amp; index.html12FROM nginxCOPY ./index.html /usr/share/nginx/html/index.html 基于nginx这个镜像。将文件夹下的index.html拷贝到镜像container下的 /usr/share/nginx/html/下面 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello Docker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Test&lt;/body&gt;&lt;/html&gt; 这里随便写了一个（用来替换默认的nginx欢迎页） docker image build -t dockerTest . 1234➜ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEdocker-test latest 65a48f14f1c1 20 seconds ago 133MB docker-test已经生成 docker container run -d -p 80:80 docker-test 运行容器指定端口80:80 成功！ 以上https://github.com/laclys/Front-End_practice/issues/153 docker学习汇总版","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Snowpack","date":"2020-07-20T15:00:11.813Z","path":"2020/07/21/Snowpack/","text":"什么是Snowpack Snowpack is a modern, lightweight toolchain for web application development. Traditional dev bundlers like webpack or Parcel need to rebuild &amp; rebundle entire chunks of your application every time you save a single file. This introduces lag between changing a file and seeing those changes reflected in the browser, sometimes as slow as several seconds. We call this new approach O(1) Build Tooling. 简而言之就是利用原生ES Modules(几乎所有现代浏览器都支持这个特性，当然除了IE, 支持IE11),无需打包工具（Webpack，Parcel）便能将代码结果实时展现在浏览器中的No build step needed!构建工具。还有一个宣传点就是Snowpack是一个时间复杂度O(1)的构建系统。像webpack这种打包工具是一个时间复杂度O(n)的过程，一个文件变更，你不止重新构建这一个文件，而是多个相关文件甚至整体一整块，要经历build -&gt; bundle recompilation这个过程。Snowpack呢，则是分别构建每一个文件 。在开发过程中，更改了某个文件，只需要重建这一个文件build(file) =&gt; result单个文件单个缓存(换言之，如果你不变更xx文件，那就永远不用重构它)。加载页面也是，它只会请求当前所需的那些文件。开发环境只要一次Snowpack，修改源码能够实时反馈在浏览器上，可以获得更快的开发体验。当然Snowpack也不是完完全全的bundleless，当然这个是后话 支持 框架： React、Preact、Vue、Svelte、Tailwind CSS(snowpack2.0 已经内置了 JSX 和 Typescript 文件的处理) Tooling: Babel、TypeScript、PostCSS 官方提供模板：Create Snowpack App HMR Dev Request Proxy Environment Variables HTTPS&#x2F;HTTP2(HTTP2的多路复用、合并请求就能解决Snowpack多构建文件的问题) StartSnowpack官方提供了创建项目的模板，这里使用@snowpack/app-template-react npx create-snowpack-app demo –template @snowpack&#x2F;app-template-react 创建完的目录是这样的 这里说明几点 public 文件下用来存放公共文件以及模板, 可以直接通过路径访问,如 public 文件下的 favicon.ico 开启可以通过 http://localhost:8080/favicon.ico 来打开 src 文件 放置组件和页面还有样式等 web 内容, src 里的静态内容通过编译以后可以通过 dist 来访问,如 http://localhost:8080/_dist_/logo.svg[Demo]: https://github.com/laclys/skarner snowpack是支持热更新的 12345// index.jsxif (import.meta.hot) &#123; import.meta.hot.accept();&#125; 不像 webpack 使用向页面添加 script 标签来加载新模块，snowpack 直接使用了原生的 dynamic import 来加载新模块,也算符合node_modules&#x2F;snowpack&#x2F;assets&#x2F;hmr.js 1234567891011121314151617181920/** Called when a new module is loaded, to pass the updated module to the &quot;active&quot; module */async function runModuleAccept(id) &#123; const state = REGISTERED_MODULES[id]; if (!state) &#123; return false; &#125; if (state.isDeclined) &#123; return false; &#125; const acceptCallbacks = state.acceptCallbacks; const updateID = Date.now(); for (const &#123;deps, callback: acceptCallback&#125; of acceptCallbacks) &#123; const [module, ...depModules] = await Promise.all([ import(id + `?mtime=$&#123;updateID&#125;`), ...deps.map((d) =&gt; import(d + `?mtime=$&#123;updateID&#125;`)), ]); acceptCallback(&#123;module, deps: depModules&#125;); &#125; return true;&#125; 问题 不完全的bundleless： 开发环境业务代码直接bundleless。对node_modules做了一层bundle处理。生产环境打包提供两套技术module/nomodule.官方维护了两套打包插件（@snowpack/plugin-webpack &#x2F; @snowpack/plugin-parcel为生产环节打包。也算是一种渐进式 但是需要承担开发与生产环境构建结果不一致的风险 对sass、less处理不够友好，需要手动处理. 1234&quot;scripts&quot;: &#123; &quot;run:sass&quot;: &quot;sass src/css:public/css --no-source-map&quot;, &quot;run:sass::watch&quot;: &quot;$1 --watch&quot;&#125; (怎么处理css的) 12// 这种语法目前浏览器是不支持的import &#x27;./style.css&#x27; snowpack将css文件变成一个注入样式的js模块 （import ‘.&#x2F;style.css.proxy.js’;）同理图片 demo.png -&gt; demo.png.proxy.js 对ESM强依赖,随之带来了很多 CommonJS 的模块依赖引入问题。比如antd需要以这种方式使用 1234567import Button from &#x27;antd/es/button&#x27;;import List from &#x27;antd/es/list&#x27;;import Avatar from &#x27;antd/es/avatar&#x27;;// cssimport &#x27;antd/es/button/style/css&#x27;;import &#x27;antd/es/list/style/css&#x27;;import &#x27;antd/es/avatar/style/css&#x27;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"bundleless","slug":"bundleless","permalink":"http://yoursite.com/tags/bundleless/"}]},{"title":"说说React16的生命周期","date":"2019-03-12T16:53:39.211Z","path":"2019/03/13/说说React16的生命周期/","text":"React16算是React诞生至今变化相当大的一个版本，在v16版本中陆陆续续新增&#x2F;修改了很多地方。最新的release版本已经到了v16.8.4。不管是平时工作还是自己学习都已经使用上了v16这个版本 这里就简单说一下v16里的生命周期(虽说是老生常谈，但仔细看文档还是发现了一些之前没注意、不怎么用的东西比如getDerivedStateFromProps和getSnapshotBeforeUpdate) react生命周期分三个阶段：挂载、更新、卸载 , v16多出了一个异常捕获(componentDidCatch) 挂载 constructor static getDerivedStateFromProps (之前没注意到这个) render componentDidMount 这里我们主要看一下constructor、componentWillMount和static getDerivedStateFromProps constructor: 初始化 state(注意避免使用props给state赋值) 给方法绑定this但在v16之后这两件事在constructor外面做会更直观更简单(v16之后constructor使用场景会变少)eg：123456789class Test extends Component &#123; state = &#123; a: 1 &#125; handleClick = (e) =&gt; &#123; // xxx &#125;&#125; componentWillMount: v16会告诫开发者componentWillMount这个函数会在未来的版本删去。我们可以先想想之前这个生命周期用来做什么？ - AJAX请求，然后执行 setState 重新渲染？ 但是在componentWillMount中进行这样的操作是在不是很妥当，特别在SSR项目中(这里不展开)。因此说到底它没什么用，被”删掉”也是合情合理 static getDerivedStateFromProps 这个就是再次看文档的新发现。上面说到应避免使用props给state赋值。v16给与了我们这个静态方法（挂载组件时，它会在render之前执行）eg： 12345678910111213// getDerivedStateFromProps的返回值将作为setState的参数，如果返回null，则不更新state，不能返回object 或 null 以外的值，否则会警告。class Test2 extends Component &#123; state = &#123; b: 0 &#125; static getDerivedStateFromProps(props, state): State &#123; if(props.b !== state.b) &#123; return &#123; b: props.b &#125;; &#125; &#125;&#125; 另外需要提一下，getDerivedStateFromProps是静态方法，故拿不到this，所以我们需要把它设计为纯函数。 同时也会发现有了这个静态方法，componentWillReceiveProps好像也没什么用了（这就能解释为什么v16也把它’删掉咯’） 更新 static getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate 这里就说说，另一个我之前没怎么注意到的点getSnapshotBeforeUpdate 在 react 更新 dom 之前调用，此时 state 已更新； 返回值作为 componentDidUpdate 的第3个参数； 一般用于获取 render 之前的 dom 数据 eg： 12345678class Test3 extends Component &#123; getSnapshotBeforeUpdate (prevProps, prevState): Snapshot &#123; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // snapshot 是从 getSnapshotBeforeUpdate 的返回值，默认是 null &#125;&#125; componentDidCatch最后再说说这个异常捕获,用于捕获组件树的异常。v16版本引入了所谓Error Boundary的概念,而保证了发生在 UI 层的错误不会连锁导致整个应用程序崩溃。其实可以理解为try···catch通常我们可以使用这个捕获异常的生命周期钩子封装成一个这样的 decorator 来包裹可能出错的组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import React, &#123; Component &#125; from &#x27;react&#x27;export default (message = &#x27;出错啦!&#x27;) =&gt; (TargetComponent) =&gt; &#123; class ErrorBoundary extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; hasError: false, error: null, info: null &#125; &#125; componentDidCatch (error, info) &#123; this.setState(&#123; hasError: true, error, info &#125;) &#125; render () &#123; const &#123; hasError &#125; = this.state if (hasError) &#123; return ( &lt;div className=&#x27;error-boundary&#x27;&gt; &lt;p className=&#x27;error-boundary-message&#x27;&gt; &#123; message &#125; &lt;/p&gt; &#123; this.renderError() &#125; &#123; this.renderComponentStack() &#125; &lt;/div&gt; ) &#125; return ( &lt;TargetComponent &#123; ...this.props &#125; /&gt; ) &#125; renderError () &#123; const &#123; error &#125; = this.state if (!error) &#123; return null &#125; return ( &lt;div className=&#x27;error-boundary-info&#x27;&gt; &lt;h6&gt;Error Stack:&lt;/h6&gt; &lt;div&gt; &#123; error.stack.split(&#x27;\\n&#x27;).map((line, index) =&gt; &#123; return ( &lt;p key=&#123; index &#125;&gt;&#123; line &#125;&lt;/p&gt; ) &#125;) &#125; &lt;/div&gt; &lt;/div&gt; ) &#125; renderComponentStack() &#123; const &#123; info &#125; = this.state if (!info || !info.componentStack) &#123; return null &#125; return ( &lt;div className=&#x27;error-boundary-info&#x27;&gt; &lt;h6&gt;ErrorInfo componentStack:&lt;/h6&gt; &lt;div&gt; &#123; info.componentStack.split(&#x27;\\n&#x27;).map((line, index) =&gt; &#123; return ( &lt;p key=&#123; index &#125;&gt;&#123; line &#125;&lt;/p&gt; ) &#125;) &#125; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125; return ErrorBoundary&#125; 完整新生命周期12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &#x27;react&#x27;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); // 初始化state方式（1） this.state = &#123; &#125; &#125; static defaultProps = &#123; &#125; // 初始化state方式（2） state = &#123; &#125; static getDerivedStateFromProps(props, state) &#123; return state &#125; componentDidCatch(error, info) &#123; &#125; render() &#123; &#125; componentDidMount() &#123; &#125; shouldComponentUpdate(nextProps, nextState) &#123; &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; &#125; componentWillUnmount() &#123; &#125;&#125; 以上~","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React Portal 小谈","date":"2018-12-13T16:08:36.342Z","path":"2018/12/14/React_Portal/","text":"最近在看ReactV16带来的新东西，V16版本直接支持了Portal。今儿就总结一下Portal这个自己不是那么熟悉却又非常重要的“传送门”吧。先说说为什么需要传送门。React的世界一切皆组件，进行render就需要一个root根节点进行挂载。组件套组件一层一层，不过最外面一层都是挂在在这个root根节点上的。 有一个常见的需求Dialog(弹窗),通常它会显示在屏幕正中央，它应该是一个独立的组件。因此将这个弹窗组件放在根节点下的子组件里显然是不合适的。我们希望将其渲染在和root根节点同级的DOM上在React组件树的最顶层。样式独立，没必要受其他组件的干扰。除了Dialog需要在最顶层渲染之外，我们还希望(也可以说是诉求)在不同的业务组件中去使用它。这里就需要Portal咯。 （ 天野喜孝展 ） V16之前去实现Dialog上代码 12345678910111213141516171819202122232425262728293031323334353637383940import React from &#x27;react&#x27;import &#123; unstable_renderSubtreeIntoContainer, unmountComponentAtNode &#125; from &#x27;react-dom&#x27;class Dialog extends React.Component &#123; constructor(props) &#123; super(props) &#125; componentDidMount() &#123; const doc = window.document this.node = doc.createElement(&#x27;div&#x27;) doc.body.appendChild(this.node) this.renderPortal(this.props) &#125; componentDidUpdate() &#123; this.renderPortal(this.props) &#125; componentWillUnmount() &#123; unmountComponentAtNode(this.node) window.document.body.removeChild(this.node) &#125; render() &#123; return null &#125; renderPortal(props) &#123; unstable_renderSubtreeIntoContainer( this, //当前组件 &lt;div class=&#x27;dialog&#x27;&gt; &#123;props.children&#125; &lt;/div&gt;, this.node ) &#125;&#125; render返回的是null，在componentDidMount下在body上创建一个div。通过renderPortal将组件内容（props.children）塞进去 这里主要用了 react-dom中 unstable_renderSubtreeIntoContainer, unmountComponentAtNode这两个库。其中unstable_renderSubtreeIntoContainer算是一个React标准外的API，作用嘛就是“传送门”把一部分组件结构塞到另外一个地方。 unmountComponentAtNode则是在componentWillUnmount这个生命周期里调用去清理unstable_renderSubtreeIntoContainer产生的副作用 V16实现DialogReact V16真的是一个巨大的版本。本身支持了Portal。提供了createPortal函数。我们就不需要在componentDidMount、componentDidUpdate中renderPortal也不需要在去通过unmountComponentAtNode清理副作用 12345678910111213141516171819202122232425import React from &#x27;react&#x27;import &#123; createPortal &#125; from &#x27;react-dom&#x27;class Dialog extends React.Component &#123; constructor(props) &#123; super(props) this.node = doc.createElement(&#x27;div&#x27;) window.document.body.appendChild(this.node) &#125; componentWillUnmount() &#123; window.document.body.removeChild(this.node) &#125; render() &#123; return createPortal( &lt;div class=&#x27;dialog&#x27;&gt; &#123; this.props.children &#125; &lt;/div&gt;, this.node ) &#125;&#125; 以上~~~ 11中旬开始，异常地忙碌。项目需求真的是无穷无尽，大佬开会表示19年的需求都排满了。 代码代码何时是个头。 前两天和仍然在日本的好友聊天，日本的生活还是那么波澜不惊、按部就班小日子蛮惬意。回想自己从日本回来这几年，一开始疯狂焦躁了一波，之后慢慢平稳努力学技术、看书一直坚持。技术、工资都再上涨，除了这些随之而来的还有不断上涨的焦虑。有时候未来真的不敢想。 睡觉🛌","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"ReactSSR样式及SEO","date":"2018-10-19T04:01:29.196Z","path":"2018/10/19/ReactSSR样式及SEO/","text":"前一篇主要记录了一下SSR配置以及结合Redux的使用。这里简单说一下React SSR中样式处理和更优雅的SEO SSR样式在React客户端渲染，添加样式很容易。写一个css样式文件，在对应组件中引用。标签上通过className这个属性调用对应样式就万事Ok了。当然我们需要在webpack中配置loader来解析css文件。一般的配置如下（使用css modules）： 12345678910111213module: &#123; rules: [&#123; test: /\\.css?$/, use: [&#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoader: 1, modules: true, localIdentName: &#x27;[name]_[local]_[hash:base64:5]&#x27; &#125; &#125;] &#125;]&#125; 需要先通过css-loader解析css文件，之后再通过style-loader将样式放在html的style标签中。 那么SSR也这样行吗~ 1yarn dev 跑一下服务，发现命令行报这个错误： 1234 return window &amp;&amp; document &amp;&amp; document.all &amp;&amp; !window.atob; ^ReferenceError: window is not defined 原因在于服务器端渲染哪里有window对象，哪里有DOM啊。我们是通过虚拟DOM。renderToString这个方法生成出来的html字符串。stackoverflow搜了一下发现了isomorphic-style-loader 这个专门用于同构的style-loader。话不多少搞起来。客户端的webpack配置不需要变更还是使用css-loader+style-loader。服务器端就使用css-loader+isomorphic-style-loader了(和style-loader用法一波一样) 1234567891011121314// webpack.server.js module: &#123; rules: [&#123; test: /\\.css?$/, use: [&#x27;isomorphic-style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoader: 1, modules: true, localIdentName: &#x27;[name]_[local]_[hash:base64:5]&#x27; &#125; &#125;] &#125;] &#125; 配置好了Run一下，不报错了但是会闪一下屏。禁用掉js发现server端生成的html并没有样式，当客户端JS接管程序之后才会有样式出现。这样的体验相当糟糕。当然我们确实没有向服务器端生成的HTML添加style标签。现在服务器返给我们的html是这样的 12345678910111213141516return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#x27;root&#x27; &gt;$&#123; content &#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123; JSON.stringify(store.getState()) &#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27; &gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ` 这时我们想到了context这个玩意。在server端render之前。我们设置一个 123let context = &#123; css: []&#125; 我们还知道在服务端渲染的时候有this.props.staticContext这样一个props拿到我们设置context。另外isomorphic-style-loader提供给我们了_getCss()这个方法。可以在SSR过程中拿到样式。有了这两个必要条件。我们就可以在每一个用到样式的Component中通过componentWillMount这个生命周期添加这样一段代码： 12345componentWillMount () &#123; if (this.props.staticContext) &#123; // 只有服务端渲染时候有this.props.staticContext以及_getCss() this.props.staticContext.css.push(styles._getCss()) &#125;&#125; 这样样式就存储在context这个变量的css数组中咯，改造一下server端的html输出代码： 123456789101112131415161718const cssStr = context.css.length ? context.css.join(&#x27;\\n&#x27;) : &#x27;&#x27; return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;style&gt;$&#123;cssStr&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#x27;root&#x27; &gt;$&#123;content&#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123;JSON.stringify(store.getState())&#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27; &gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ` 万事👌，当然我们可以进一步优化，把componentWillMount所做的事情提出来搞一个HOC（高阶组件）。 withStylesHOC.js 123456789101112131415161718import React, &#123; Component&#125; from &#x27;react&#x27;export default (DecoratedComponent, styles) =&gt; &#123; return class NewComponent extends Component &#123; componentWillMount () &#123; if (this.props.staticContext) &#123; this.props.staticContext.css.push(styles._getCss()) &#125; &#125; render () &#123; return &lt;DecoratedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 这样简单的封装一个HOC，之后涉及样式的时候直接通过withStylesHOC包裹一下就好。例如一个结合Redux的Home组件： 1export default connect(mapState, mapDispatch)(withStyle(Home, styles)) SSR-SEO费大力气通过一个node中间层去实现首屏的SSR，除开首屏速度之外，就是SEO这一大块了，对于一个商业网站来讲真的很重要。SEO（Search Engine Optimization）– 通过一些技术手段让网站在搜索引擎的排名尽量靠前一点。由于客户端渲染出来的网站只有&lt;div id=&#39;root&#39;&gt;这样的html节点。大多数搜索引擎分析不出来网站上有什么。SSR直接渲染出来HTML，这样对搜索引擎就友好了很多。 SSR中的SEO这里我们使用github上的一个库react-helmet首先需要在对应的页面组件中引入react-helmet，就可以在Helmet标签内自由添加title、meta咯 12345678910111213141516// Home.jaximport &#123; Helmet &#125; from &#x27;react-helmet&#x27;class Home extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;Helmet&gt; &lt;title&gt;SRR-Home&lt;/title&gt; &lt;meta name=&#x27;description&#x27; content=&#x27;this is a home Component&#x27; /&gt; &lt;/Helmet&gt; ... ... &lt;/&lt;Fragment&gt;&gt; ) &#125;&#125; 之后按照readme所说的。在server端这样处理 12ReactDOMServer.renderToString(&lt;Handler /&gt;);const helmet = Helmet.renderStatic(); 并在返回的html字符串中 $&#123;helmet.title.toString()&#125; $&#123;helmet.meta.toString()&#125;进行填充 12345678910111213141516&lt;html&gt; &lt;head&gt; $&#123;helmet.title.toString()&#125; $&#123;helmet.meta.toString()&#125; &lt;style&gt;$&#123;cssStr&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#x27;root&#x27; &gt;$&#123;content&#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123;JSON.stringify(store.getState())&#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27; &gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 重新跑一下 搞定！ 当然SSR-SEO绝不这么简单。仅仅在页面上添加head标签内加上title 和meta标签影响是有限的。8102年的搜索爬虫已经不单单去匹配title和 description，而是全稳的匹配（也就是说title和descript有影响但是影响很小）搜索爬虫会把整个网站所有的文本收集起来进行分析。 那么如何做好SEO题外话顺便说一下如何做好SEO。一个网站无非三大块内容，文字、多媒体、链接。要做到的是文字的原创性，图片的原创性以及高清度还有站内链接尽量和站内内容相关。 就这样吧~以上","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"ssr","slug":"ssr","permalink":"http://yoursite.com/tags/ssr/"},{"name":"seo","slug":"seo","permalink":"http://yoursite.com/tags/seo/"}]},{"title":"React SSR Note(1)","date":"2018-10-16T09:32:59.917Z","path":"2018/10/16/React SSR Note(1)/","text":"SSR已经不是什么新词、新概念了。为了解决React、Vue这类单页面（SPA）带来的首屏过慢以及SEO等问题随之而出。Vue、React官方也一直再跟进相关的支持。同时社区也诞生了Next.js(React)以及Nuxt(vue)这类已经配置好，开箱即用的SSR解决方案。 之前在研究学习Webpack的时候，折腾过React SSR的配置和使用。从零配置Webpack4.0搭建一个React工程并且在蛮多自己瞎搞的项目中使用过，这几周自己再折腾SSR与Redux的结合。这一全面总结一下，就当温故知新了。 什么是服务端渲染&#x2F;为什么使用服务端渲染服务端渲染顾名思义浏览器通过url向服务器发送请求，服务器处理好页面的内容将整个页面返还给浏览器。每当请求一个url，服务器要将该url对应的页面内容发送给浏览器。 而SPA单页面应用则是在一开始一股脑将整个bundle.js加载进来。具体流程如下： 浏览器发送请求 -&gt; 服务器返回HTML(空的骨架) -&gt; 浏览器发送bundle.js -&gt; 服务器返回bundle.js -&gt;浏览器执行React&#x2F;Vue代码 之后所有的url变成操作都通过这个js来处理，不需要再重新加载整个页面。web应用更具响应性，用户体验更好。但是由于一开始要加载一大坨bundle.js就会带来首屏过慢的问题。由于整个网页的内容都在js中，自然而然html源码什么都没有，不利于SEO。 为了解决痛点SSR就来了。它不是传统意义的服务端渲染，只是首屏渲染，首屏通过服务器直接生成，之后的由客户端（浏览器）接管。这样既能解决首屏速度、SEO还能同事拥有单页面应用带给用户的流畅性。(这里有一个专有名词叫做：同构–一套代码在服务器执行一遍，在客户端执行一遍) 具体流程如下： 浏览器发送请求 -&gt; 服务器运行React代码生成页面 -&gt; 服务器返回页面 -&gt; 浏览器加载bundle.js -&gt; bundle.js的React代码在浏览器重新执行 -&gt; bundle.js的React重新接管页面操作。 这里主要说说React中的SSR核心由于虚拟DOM的存在(真实DOM的JS对象映射)在SPA中 1ReactDom.render(&lt;Home /&gt;, id/root) 在SSR中虚拟dom的存在让SSR变得很简单 1renderToString(&lt;Home /&gt;) 把虚拟dom转化为字符串，返给服务器就是了 Simple Demo首先可以在分别创建server文件夹及client文件夹。我们这里简单的写写一套相同内容的代码server&#x2F;index.js 123456789101112131415161718192021222324252627282930313233import express from &#x27;express&#x27;import React from &#x27;react&#x27;import &#123; renderToString &#125; from &#x27;react-dom/server&#x27;import &#123; StaticRouter &#125; from &#x27;react-router-dom&#x27;import Routes from &#x27;../routes&#x27;const app = express() // 通过express搭建一个服务器app.use(express.static(&#x27;public&#x27;)) // 只要请求静态文件就在public这个文件夹中找app.get(&#x27;/&#x27;, function(req, res) &#123; const content = renderToString( // 在server使用react-router-dom需要用StaticRouter &lt;StaticRouter location=&#123; req.path &#125; context=&#123;&#123;&#125;&#125; &gt; &#123; Routes &#125; &lt;/StaticRouter&gt;) // 通过 &lt;script src=&#x27;/index.js&#x27; &gt;&lt;/script&gt; 在调用client res.send(` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#x27;root&#x27; &gt;$&#123; content &#125;&lt;/div&gt; &lt;script src=&#x27;/index.js&#x27; &gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `)&#125;)var server = app.listen(3000) client&#x2F;index.js 1234567891011121314import React from &#x27;react&#x27;import ReactDom from &#x27;react-dom&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import Routes from &#x27;../routes&#x27;const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &#123; Routes &#125; &lt;/BrowserRouter&gt; )&#125;ReactDom.hydrate(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) client端就是我们熟悉的React代码这里就不在废话 sever、client共用了一个路由配置routes.js 1234567891011import React from &#x27;react&#x27;import &#123; Route &#125; from &#x27;react-router-dom&#x27;import Home from &#x27;./containers/Home&#x27; //一个简单的Componentexport default ( &lt;div&gt; &lt;Route path=&#x27;/&#x27; exact component=&#123; Home &#125; &gt;&lt;/Route&gt; &lt;/div&gt;) 这里着重说一下webpack配置.这里拆成个三个文件。webpack.base.js 、webpack.client.js、webpack.server.js 1234567891011121314151617// webpack.base.js module.exports = &#123; module: &#123; rules: [&#123; test: /\\.js?$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/, options: &#123; presets: [&#x27;react&#x27;, &#x27;stage-0&#x27;,[&#x27;env&#x27;, &#123; targets: &#123; browsers: [&#x27;last 2 versions&#x27;] &#125; &#125;]] &#125; &#125;] &#125;&#125; 123456789101112131415// webpack.client.jsconst path = require(&#x27;path&#x27;)const merge = require(&#x27;webpack-merge&#x27;)const config = require(&#x27;./webpack.base&#x27;)const clientConfig = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/client/index.js&#x27;, output: &#123; filename: &#x27;index.js&#x27;, path: path.resolve(__dirname, &#x27;public&#x27;) &#125;&#125;module.exports = merge(config, clientConfig) 123456789101112131415161718// webpack.server.jsconst path = require(&#x27;path&#x27;)const nodeExternals = require(&#x27;webpack-node-externals&#x27;) // 排除 node_modules 目录中所有模块const merge = require(&#x27;webpack-merge&#x27;)const config = require(&#x27;./webpack.base&#x27;)const serverConfig = &#123; target: &#x27;node&#x27;, mode: &#x27;development&#x27;, entry: &#x27;./src/server/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;build&#x27;) &#125;, externals: [nodeExternals()]&#125;module.exports = merge(config, serverConfig) 这样一个最简单的SSR Demo就搞定了 SSR与Redux、React-RouterSSR同构配合Redux使用还蛮复杂的，中间涉及到数据的注水和脱水。首先我们面临的第一个问题是server端怎么根据路由，往store里面加数据。这里我们通过数组对象的方式设置Route。完整Project： https://github.com/laclys/rengar 比如： 123456789101112131415161718192021222324export default [&#123; path: &#x27;/&#x27;, component: App, loadData: App.loadData, key: &#x27;app&#x27;, routes: [&#123; path: &#x27;/&#x27;, component: Home, exact: true, loadData: Home.loadData, key: &#x27;home&#x27; &#125;, &#123; path: &#x27;/translation&#x27;, component: Translation, exact: true, loadData: Translation.loadData, key: &#x27;translation&#x27; &#125;, &#123; component: NotFound, &#125; ]&#125;] 这么一个路由。用过loadData进行server端对应数据的拉取（server端没有生命周期）。比如在Home这个组件里我们定义了一个loadData静态方法 1234Home.loadData = (store) =&gt; &#123; // 负责在服务器端渲染之前，把这个路由需要的数据提前加载好 return store.dispatch(getHomeList())&#125; 顺便提一下客户端拉取数据当然 12345componentDidMount() &#123; if (!this.props.list.length) &#123; // 这层判断为了避免server端已经拉取数据了，没必要重复拉取。至于怎么从server渲染的页面拿到数据后面再说 this.props.getList() &#125;&#125; 有了这些准备就可以在server端生成首屏的html。这里import &#123; matchRoutes &#125; from &#39;react-router-config&#39;使用matchRoutes来遍历routes 123456789101112131415161718192021222324252627app.get(&#x27;*&#x27;, function (req, res) &#123; const store = getStore(req) // 根据路由的路径，往store里面加数据 const matchedRoutes = matchRoutes(routes, req.path) const promises = [] matchedRoutes.forEach(item =&gt; &#123; // 匹配含有loadData的路由，执行并赋值到store中 if (item.route.loadData) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; item.route.loadData(store).then(resolve).catch(resolve) &#125;) promises.push(promise) // 不管数据加载成功还是失败，把能准备的数据都准备好。更好的容错不必担心那个接口请求失败。都会执行promise.all &#125; &#125;) Promise.all(promises).then(() =&gt; &#123; const context = &#123;&#125; const html = render(store, routes, req, context) // 生成html。 if (context.action === &#x27;REPLACE&#x27;) &#123; res.redirect(301, context.url) &#125; else if (context.NOT_FOUND) &#123; // 处理404页面 res.status(404) res.send(html) &#125; else &#123; res.send(html) &#125; &#125;)&#125;) 渲染html的render函数 1234567891011121314151617181920212223242526272829export const render = (store, routes, req, context) =&gt; &#123; const content = renderToString( &lt;Provider store=&#123; store &#125; &gt; &lt;StaticRouter location=&#123; req.path &#125; context=&#123; context &#125; &gt; &lt;div&gt; &#123; renderRoutes(routes) &#125; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt;) return ` &lt;html&gt; &lt;head&gt; &lt;title&gt;ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#x27;root&#x27; &gt;$&#123; content &#125;&lt;/div&gt; &lt;script&gt; window.context = &#123; state: $&#123; JSON.stringify(store.getState()) &#125; &#125; &lt;/script&gt; &lt;script src=&#x27;/index.js&#x27; &gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `&#125; 其中 12345&lt;script&gt; window.context = &#123; state: $&#123; JSON.stringify(store.getState()) &#125; &#125;&lt;/script&gt; 通过这种方式将server端已经获取的store数据进行注入。到时客户端js接管之后直接从context中拿 client&#x2F;index: 123456789101112131415const store = getClientStore() const App = () =&gt; &#123; return ( &lt;Provider store=&#123; store &#125; &gt; &lt;BrowserRouter&gt; &lt;div&gt; &#123; renderRoutes(routes) &#125; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; )&#125;ReactDom.hydrate(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) getClientStore 1234export const getClientStore = () =&gt; &#123; const defaultState = window.context.state // 客户端getstore时，拿server已经获取过得数据。这块叫做脱水 return createStore(reducer, defaultState, applyMiddleware(thunk.withExtraArgument(clientAxios)))&#125; thunk.withExtraArgument是redux-thunk中一个可以传入一个值。在使用redux-thunk时候调用 顺道提一下服务器端获取请求cookie这块。可以通过axios的create方法拿到 123456789const createInstance = (req) =&gt; axios.create(&#123; baseURL: &#x27;http://47.95.113.63/ssr/&#x27;, headers: &#123; cookie: req.get(&#x27;cookie&#x27;) || &#x27;&#x27; &#125;&#125;)export default createInstance 以上！捣鼓之后SSR确实是一个有意思的东西。很多东西不能说是坑，只能说是自己还没了解到。后续还会再看看CSS样式在server端中的处理和更好的SEO处理。","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"SSR","slug":"SSR","permalink":"http://yoursite.com/tags/SSR/"}]},{"title":"小程序Note2","date":"2018-09-27T15:16:00.469Z","path":"2018/09/28/小程序Note2/","text":"最近一个月，主要的精力还是在小程序这边，公司的项目是，自己闲暇之余写的小项目也是。公司项目就不说了，自己的小项目涙曇前后用了一个月，101commits完成了1.0.0版。从有想法到自己设计再到开发完完全全走完这一套流程，还是很满足的。 这里还是聊聊最近编写小程序一些问题和解决方案 （中秋在三里屯人行天桥拍到的日落，很美） 简单说说登录小程序登录，这里抛开后端（其实镇等复杂的还是获取用户登录信息并涉及上传用户到服务器这个过程的后端操作）说说前端登录。 首先说说1.9版本新加的显示用户信息的方法（不需要授权，静默获取）如果只是想在UI显示用户的信息比如昵称，来自那里···，就可以用&lt;open-data&gt;这个组件。使用起来超级简单，弊端就是没有授权，并没有真正拿到数据。如果要上传用户信息到服务器，就必须getUserInfo在js中拿到数据。 下面再说说授权登录。 早期获取用户登录信息是通过wx.getUserInfo这个接口获取的，使用起来非常简单。但微信大概是觉得API的方式太过灵活，微信团队不希望开发者滥用这些方法，所以登录授权的操作放在了button这个组件上。让用户使用组件主动点击 &lt;button open-type=&quot;getUserInfo&quot; bindgetUserInfo=&quot;handleUserInfo&quot;&gt;授权&lt;/button&gt; 这样。授权弹窗谈过一次，就不再出现，可以在getUserInfo函数中拿到用户信息。然而上面这种方法有个问题就是，每次都需要用户点击。我们需要一个更灵活的随时可以拿到用户信息的方式。这里又要使用先前说的wx.getUserInfo接口了。这个接口并没有废弃需要和button组件配合使用。只有用户授权通过，wx.getUserInfo才可以获取用户信息。这里我们可以使用wx.setting来判断用过是否已经授权登录.这里简单写了一个userAuthorized函数，放在生命周期onload中就可以判断用户是否授权，并拿到值咯。 12345678910111213141516171819userAuthorized: function() &#123; wx.getSetting(&#123; success: data =&gt; &#123; if (data.authSetting[&#x27;scope.userInfo&#x27;]) &#123; // 用户授权了 wx.getUserInfo(&#123; success: data =&gt; &#123; console.log(data) this.setData(&#123; authorized: true, userInfo: data.userInfo &#125;) &#125; &#125;) &#125; &#125; &#125;)&#125; 这里还要说的就是由于登录、分享这类操作微信强制用button组件\b点击执行。为了样式的自由，可以简单写一个image-button组件。 wxml: 123&lt;button bind:getuserinfo=&quot;onGetUserInfo&quot; open-type=&quot;&#123;&#123; openType &#125;&#125;&quot; plain class=&quot;container&quot; &gt; &lt;slot name=&quot;img&quot; &gt;&lt;/slot&gt;&lt;/button&gt; wxss: 12345/* 去覆盖btn的默认样式 */.container &#123; padding: 0 !important; border: none !important;&#125; js: 1234567891011121314151617Component(&#123; options: &#123; multipleSlots: true &#125;, properties: &#123; openType: String &#125;, methods: &#123; onGetUserInfo: function(ev) &#123; this.triggerEvent(&#x27;getuserinfo&#x27;, ev.detail) &#125; &#125;&#125;) wx.navigateBack（）返回上一页面如何传参数一开始解决这个问题，采用的是往localStorage中存值、取值的方式。维护localStorage是个蛮麻烦的一件事。之后发现了getCurrentPages()函数获取页面栈的实例从而获取上一个页面数据的方式。代码如下非常好用 123456789101112131415let pages = getCurrentPages(); // 获取页面堆栈let currPage = pages[pages.length - 1]; //当前页面let prevPage = pages[pages.length - 2]; //上一个页面 //可以直接调用上一个页面对象的setData()方法，把数据存到上一个页面中去let prevData = prevPage.__data__ // 可以通过这种hack的方式获取到上一个页面的dataprevPage.setData(&#123; data：data&#125;)wx.navigateBack(&#123; delta: 1 &#125;) scroll-view隐藏滚动条方法这个是前两天才看到的 12345::-webkit-scrollbar&#123;width: 0;height: 0;color: transparent;&#125; 侧滑删除在App上蛮普遍的一个操作，小程序这边本来打算用同组另一个项目的代码，粘贴复制轻松搞定。不过他们这个组件要传定高不说还有不少多余的功能，索性自己写一个，这里就不赘言了。后续可能会维护一下 wx-side-slip-comp 后记北京的九月很舒服秋高气爽，秋天真是一个好季节。抽了两个周末分别去了青岛和南京见了一波老同学。转眼毕业四年，大家还是老样子同时也或多或少变了一些。还有漫长的两天，十一就来咯~","tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序开发遇到的一些问题和吐槽","date":"2018-08-18T17:15:02.425Z","path":"2018/08/19/小程序开发遇到的一些问题和吐槽/","text":"小程序在微信这个超级平台的带动下，这两年着实是越来越火。刚出来那一阵，翻了翻文档简单的看了看，没有组件、没有wsx(虽然现在也很难用，有总比没有强)还有无穷无尽的坑。一直没有深入去学习去了解。期间美团开源了一个mpvue，一个基于Vue的小程序开发框架。上手没什么成本，自己写了一个极其简单简陋查询快递的小程序–快递去哪儿咯。最近工作上来了小程序的需求，组内交流之后打算用小程序原生的那一套搞。现学现搞all in了两周小程序。这里记录一下遇到的一些小问题或者坑吧。 吐槽那我们就从吐槽开始 （很喜欢的一部电影） 繁琐过时的API在网页端开发web，说道处理请求相比axios、fetch已经成了主流，链式调用try···catch处理错误。但是小程序却用着过时的ES3风格的API(wx.request)。这样在使用起来很不优雅，在使用了调用的时候很容易造成回调地狱。想要使用promise这种链式调用的实行。我们不得不去封装一个HTTP类。下面是自己封装的一个HTTP类 123456789101112131415161718192021222324252627282930313233export class HTTP &#123; request(&#123; url, data=&#123;&#125;, method=&quot;GET&quot; &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; this._request(url, resolve, reject, data, method) &#125;) &#125; _request(url, resolve, reject, data=&#123;&#125;, method=&quot;GET&quot;) &#123; wx.request(&#123; url: config.api_base_url + url, method, data, header: &#123; &#x27;content-type&#x27;: &#x27;application/json&#x27; &#125;, success: (res) =&gt; &#123; const code = res.statusCode.toString() // 判断状态码 if (code.startsWith(&#x27;2&#x27;)) &#123; resolve(res.data) &#125; else &#123; reject() &#125; &#125;, fail: (err) =&gt; &#123; reject() &#125; &#125;) &#125;&#125; 面向JSON编程接着API设计的过时，不得不吐槽这种面向JSON编程的方式。开发一个小程序需要app.json去配置全局的应用配置、路由配置还有全局UI配置。每个页面，每个组件也有相应json文件去配置。 wxs真的很难用作为页面的脚本语言，微信这边自己现成的JS不用，自己搞了一套嵌入式脚本语言，里面只能写ES3的语法不说（还不是完整版的ES3语法）没有 Array, Object 对象；或遇到引入 lodash 会报错 TypeError: Cannot read property ‘prototype’ of undefined js页面中无法使用绝对路径 wxss 里的注释只能用 &#x2F;…&#x2F; 写法，不能用 &#x2F;&#x2F;… component组件中与支持onShow这个生命周期 遇到的一些问题 在开发横向滑动图片的组件的时候，自然而然想到在sroll-view组件上添加scroll-x属性，但是依然划不动。 解决：父级在设置宽高的同时必须设white-space: nowrap; 子级要用display: inline-block;用浮动都不行 页面配置背景色可使用 backgroundColor,模拟器里并没有生效。最后发现backgroundColor 是指窗体背景颜色，而不是页面背景色。 textarea组件是原生组件，placeholder-style 目前只支持设置 fontSize、fontWeight、color 属性 map、textarea 为原生组件，页面层级最高，就算设置了z-index也无法被覆盖。（这个是真的坑） text组件，看名字我们自然而然想到这个是不是和网页中的span标签一样。但是两个text标签放在一起会出现高度不一致的问题，以及类似网页中的pre标签，会保留文本中的空格和换行符号（开发的时候发现怎么换行了，一个劲的调样式，结果发现&#x3D;。&#x3D;真的是无语） 解决: 索性全换成view组件了 发消息模版时需要获得提交表单时的 formId，通过 form 及键盘右下角完成提交事件对象 e.detail 获取不到 formId，只能通过 form button 来获取。 component在处理数据变化的时候 可以使用properties中设置的observe或者页面中写wxs,wxs其实相当于vue里面的过滤器。这两个可以结合情况使用 wx:if 和hidden结合实际情况适用。hidden不能直接赋值在自定义组件上，需要放在组件里的最外层的view上。用过传参的形式使用 以上 小程序的开发怎么说真的是又爱又恨，很是微妙。这两周的开发学习感觉又回到了当时研究RN的时候，当效果、成果做出来的时候很有成就感。同时小程序也蛮适合自己瞎搞的，最近在搞的一个repoTeemo,除此之外这两天小程序官方有公测了serverless，感觉发挥的空间更大了。最近自己还真有个好点子，等搞完这个尝试一波（自娱自乐）","tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"2018.7","date":"2018-07-29T14:29:34.323Z","path":"2018/07/29/7月/","text":"上篇博文至今，又间隔了一个多月。其实这一个月自我感觉成长了不少，学到也用到了不少东西。一直懒于动笔拖到了七月的尾巴。 工作上工作上正式开搞了一个新项目。前端这边React全家桶。React全家桶无非就那点东西，但这回确实收获了不少。最大的收获还是工程化和拆分这一块。之前自己写前端项目亦或是在无二写RN回头来看离工程化差的好远，这次的工作才真真切切感受到了什么是前端工程。 在这次工作中，在等待后端提供接口的时间，首先做了一个纯JS的组件库，组件库分通用组件和逻辑组件两种。一开始自己不太理解已经有Antd这样UI组件库，为什么还要自己搞一套。和老大请教之后给出的解释是这样的我们所做的后台之后还会面向C端，与其用一个大而全的开源项目修改，不如一点点完善一个小项目，可以避免很多冗余的代码同时项目不仅仅只是纯UI组件还会有很多业务强相关的组件，先完善搞好组件之后正式开发项目在页面上甩组件就是咯。 在组件库开发过程中，为了方便开发，使用了Storybook这个神器。Storybook可以说是一个UI组件的开发环境,很方便的去交互测试组件，以及生成组件文档。其实官方文档也相当清楚。正如它页面展示的动图一样，交互体验去开发组件，调试测试都很方面。这里暂时不展开说了了，后续专门写一篇介绍一下。样式组件之外就是和业务强关联的业务组件。自己在这一块的开发做的不是很好，没有想清业务便着手开发在之后项目使用中，发现这里有不足那里有不足返工添加属性逻辑反反复复好几次。以后还是要先想好理清楚之后再coding。 组件库做得差不多了、后端API也开发完毕了终于到了项目开发，总体来说有了组件库的开发铺垫，正式开发起来非常效率。在豆瓣工作最直观的感受就是工作上的任务、文档清晰明了，所有研发都心照不宣地维护这个传统和文化，这点真的很难得。提issue讨论确定需求，projects任务排期。开发之后提PR，同事仔细地Review代码，最后同事的一句LGTM结束这个PR的开发。这一系列看似理所因当的，规范的流程操作，在国内快文化下太难得了。 回到前端工程上来，首先是项目拆分的很细致。就说Redux这一块actions、const、effect、reducer、sagas、store(这里是之后一个文件configure-store.js进行redux的一些配置包括区分开发和生产环境以及saga的配置)足足有六个文件夹。一开始上手的时候很懵逼，不过确实很清晰。自己在工作之余的学习中，自己的那个项目也完全按工作中的细化规模自己实践了一番。Redux虽说繁琐，不过真正搞清楚Redux工作流，熟练上手之后。Redux这种清晰的数据变化流程不要太赞。我认为Redux最能提升的不是开发效率，而是维护效率。这就是Redux的可预测性吧。再有就是从同事的代码上学到了好多，在之前的公司完全没有这种感受，自己还是要加油 工作之外这一个月，为了搞定工作以及尝试一些新东西搞了这么一个React项目Irelia,除了上面说的细化redux开发流程之外，主要尝试了完全使用&#x2F;Immutable.js去管理数据以及Styled-components这种组件的方式完成样式的书写,实践证明这两个库真的是超级好用。 先说Immutable.js，它弥补了Javascript没有不可变数据结构的问题。由于是不可变的，可以放心的对对象进行任意操作。在全局使用之后，我们就不用担心引用类型的变量所引发的一系列副作用咯。 话说工作上的项目没用immutable.js，上周五就遇到了这样一个问题。如果用Immutable.js就可以完全杜绝这块的问题了,非常省心。当然深拷贝也可以做到（差别在于性能）。immutable.js提供了很多强大的API，配合React以及Redux可以说高效、方便、安全。reducer中使用view调用需要注意的点： 既然全局使用了immutable.js，再生成新数据，获取新数据传递到action之前一定要注意将其转化成immutable（大部分情况使用fromJS就好:fromJS会包裹一个JS对象使其变成immutable对象。（内部的对象也会变））总结一句话就是：同一类型，才不会出错; pureComponent和immutable.js完美契合可以放心大胆的用。 再来说说Styled-components，可以说是css in js上的又一种尝试。让样式也组件化同时逻辑组件和展示组件分离。使用styled-components不需要再使用className属性来控制样式，而是将样式写成更具语义化的组件的形式。Styled-components的写法可以让样式暴露props让外层JS去控制。这样我们就不需要ClassName、style这样的中间人。 此外Styled-components支持全部Css特性，归根结底本质还是css，什么动画、伪类都不在话下。还有一个优点就是，我们不再需要考虑className命名问题。使用Styled-components会给生成的React组件添加一个值为随机字符串的className。使用同一个Styled-components生成的多个React组件的className是不同的，这种随机className的机制使得组件之间的className值不会冲突，从而解决了CSS全局作用域的问题，也省去了命名的麻烦。 这种控制样式的编程方式不光能解决CSS全局作用域的问题，而且移除了样式和组件间的映射关系真的好用。 Note 新版React不再推荐对象的方式去改变 123this.setState(&#123; a: 1&#125;) 推荐异步函数的形式代替对象传入setState中 12345this.setState((prevState) =&gt; &#123; return &#123; a: prevState.a + 1 &#125;&#125;) 其中preState 等价于this.state 想在最外层包一层，但又不想被显示。可以试试React16引入的Fragment。一个JSX空标签 ref&#x3D;{(input) &#x3D;&gt; { this.input &#x3D; input }}这种使用ref获取dom，一定要记得setState是异步的 说到React ref,React16.3加入了新的React.createRef API。目前获取ref dom元素有三种方法 1）String Ref 2）Callback Ref 3）React.createRefReact官方表示String Ref将会在未来版本被移出，建议用户使用Callback Ref、React.createRef来代替String Ref一些问题: React元素在创建和更新的过程中，定义成String类型的ref会被封装为一个闭包函数，等待commit阶段被执行，这样会对React性能产生一些影响。 String Ref无法被组合，当父组件已经给子组件传递了ref，那么我们就无法再在子组件上添加ref了, Callback Ref方式便可避免。 在根组件上使用无法生效。 另外，React16还另外提供了一个关于ref的API React.forwardRef，主要用于穿过父元素直接获取子元素的ref。 生命周期中componentWillReceiveProps。没有props参数是不会执行的，只有父组件接受了props才会执行，只要父组件render函数重新执行了，子组件componentWillReceiveProps就会执行。 可以通过React16生命周期中componentDidCatch，创建一个error-boundary，用来捕获其内嵌套的组件生命周期发生的错误。（* 无法捕获异步以及事件回调引发的错误） 便捷的深拷贝 JSON.parse(JSON.stringify(obj)) 判断两个对象是否相等，如果项目中没有使用immutable.js\b，可以引入lodash.isequal 12import isEqual from &#x27;lodash.isequal&#x27;isEqual(obj1, obj2) Reduxreducer可以接受state，但绝对不能修改state；store必须是唯一的；只有store才能改变自己的内容；reducer必须纯函数不能有副作用；state在其他地方只读只有在store中才能修改。每一块功能拆分一个小store，通过combineReducers合并。每一个功能(组件)的store可以使用这样的模板：其中index.js可以这么写 12345import reducer from &#x27;./reducer&#x27;import * as actionCreators from &#x27;./actionCreators&#x27;import * as constants from &#x27;./constants&#x27;export &#123; reducer, actionCreators, constants &#125; use redux chrome tool 1234567891011import &#123; createStore, compose, applyMiddleware&#125; from &#x27;redux&#x27;import thunk from &#x27;redux-thunk&#x27;import reducer from &#x27;./reducer&#x27;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || composeconst store = createStore(reducer, composeEnhancers( applyMiddleware(thunk)))export default store this.props.children可以读取组件下的子节点。this.props.children可以用React.Children.map遍历子节点，好处是不用担心数据类型是undefined还是Obj 在项目中最好分离开业务组件和UI组件。UI组件能写成Stateless方式还是要写成这种方式以提高性能。 Styled-components中可以通过innerRef拿到真实Dom 实现react页面之间的异步加载操作可以尝试使用react-loadable这个组件 以上~~~~","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Redux-saga","date":"2018-06-27T06:36:53.590Z","path":"2018/06/27/redux-saga/","text":"公司的react项目，在管理异步action这一块，都用的是redux-saga这个中间件。之前自己在做项目&#x2F;练习的时候，都是用redux-thunk这个比起saga轻量很多的解决方案。这两天正好在学习和摸索redux-saga。顺便总结一下。 redux-thunk&#x2F;redux-saga首先redux-thunk和redux-saga都是redux的中间件，目的是解决redux应用中的异步问题。redux本身是不支持异步的，action creator直接返回一个对象。这里redux-thunk通过十几行代码，判断action creator函数返回的是不是一个对象，不是对象是函数的话再用dispatch发出去。之前自己写过一个简单的redux-thunk的模拟。大致就是这样的 12345678910const thunk = (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123; // 如果是函数，执行以下；参数是dispatch和getState if (typeof action === &#x27;function&#x27;) &#123; return action(dispatch, getState) &#125; // 啥事没干 原样返回 return next(action)&#125;export default thunk redux-saga也是解决同样的问题，但是redux-saga是通过在redux原有的数据流中再加了一层，对action进行监听。捕获到监听的Action后可以派生一个新的任务对state进行维护，更改state来驱动view层变化。saga和thunk都是可以处理异步操作和协调复杂的dispatch。不同额是thunk是在action创建的时候才调用，saga是在应用入口就启动了，一直在监听action，并作出相应处理。说白了就是saga将所有的异步操作逻辑收集在一个地方集中处理。相比thunk的处理方式，更能剥离redux应用的副作用，让数据处理更加优雅（也更加麻烦&#x3D;。&#x3D;） saga核心原理是利用了generator，使异步操作流程更加优雅。sagas都是用Generator函数实现的。 以generator形式组织逻辑序列（function* + yield），把一系列的串行&#x2F;并行操作通过yield拆分开 利用iterator的可“暂停&#x2F;恢复”特性（iter.next()）分步执行 通过iterator影响内部状态（iter.next(result)），注入异步操作结果 利用iterator的错误捕获特性（iter.throw(error)），注入异步操作异常 使用下面说说怎么引入redux-saga 123456789101112import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;import createSagaMiddleware from &#x27;redux-saga&#x27;//引入saga文件import &#123; rootSaga &#125; from &#x27;./rootSaga&#x27;//使用 redux-saga 模块的 createSagaMiddleware 工厂函数来创建一个 Saga middleware。//运行 rootSaga 之前，我们必须使用 applyMiddleware 将 middleware 连接至 Store。然后使用 const sagaMiddleware = createSagaMiddleware()const middlewares = [ sagaMiddleware ]const store = createStore(rootReducer, applyMiddleware(...middlewares))sagaMiddleware.run(rootSaga) 一些Api在使用上是通过yield Effects的方式完成的。（An Effect is simply an object which contains some information to be interpreted by the middleware.） call:yield call(Generator, param)yield一个call 到Generator,saga等待Generator执行之后,接收返回值继续执行,call是堵塞的,就是等待执行完再继续执行,返回的是执行完正常返回的结果. take:是阻塞的,只有监听到他(action.type),才会继续往下执行. put:类似dispatch方法,触发一个action fork:非阻塞的,遇到它不需要等待他执行完毕,就可以继续往下执行,fork返回的是一个任务,可以被取消 cancel:针对fork方法返回的任务,进行取消 redux-saga helper take：语义相当于once takeEvery：语义相当于on，允许并发action（上一个没完成也立即开始下一个） takeLatest：限制版的on，不允许并发action（pending时又来一个就cancel掉pending的，只做最新的） takeEvery, takeLatest是在take之上的封装，take才是底层API，灵活性最大，能手动满足各种场景 一些使用场景 接口访问123456789function* fetchProducts() &#123; try &#123; const products = yield call(Api.fetch, &#x27;/products&#x27;) yield put(&#123; type: &#x27;PRODUCTS_RECEIVED&#x27;, products &#125;) &#125; catch(error) &#123; yield put(&#123; type: &#x27;PRODUCTS_REQUEST_FAILED&#x27;, error &#125;) &#125;&#125; Login&#x2F;Logout12345678function* loginFlow() &#123; while (true) &#123; yield take(&#x27;LOGIN&#x27;) // ... perform the login logic yield take(&#x27;LOGOUT&#x27;) // ... perform the logout logic &#125;&#125; 这样写就能保证action的执行顺序。LOGOUT永远在LOGIN之后发生。 优缺点 优：redux-saga的加入让流程拆分的更加细化。以同步的方式去写异步代码，代码层次结构更加清晰。便于测试 缺：拆分细化意味着流程上多一个环节，增加了代码复杂度，和开发工作量。 学习这一块，细化拆分专门写了个例子，感觉把能用的都用了：https://github.com/laclys/Ezreal 以上~~~~","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"React杂记","date":"2018-06-23T17:11:58.961Z","path":"2018/06/24/React杂记/","text":"（上海·凌空SOHO） React性能优化：性能优化老生常谈，网上的文章也一大堆，自己总结一下，也做一个记录。 1）单组件：传递参数要少传，尽可能减少React在传递参数时候的负担。当然在使用数据的时候尽可能使用一份数据，而不是重新定义一份。 在使用 函数的时候： NG： 每次执行render函数的时候bind都会执行一次 1&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt; 比上一个好一点，但每次执行render的时候都会重新生成一个函数 1&lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;&lt;/button&gt; Good： 1234constructor(props) &#123; super(props) this.handleClick = this.handleClick.bind(this) // 构造函数只会执行一次。在构造函数中绑定this&#125; 1&lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; 在传递参数的时候NG：每次都会生成新对象 1&lt;div style=&#123;color: &#x27;red&#x27;&#125;&gt;&lt;/div&gt; GOOD： 提前定义好需要的对象。目的就是使用一份数据，而不是重新定义一份 再给子组件传递参数的时候 ，只传递需要的参数。！ 2） 多组件：说道多组件有一个情况就是：子组件是不需要变化的，但是父组件的render执行了变化，子组件也会跟着再次渲染例,fu组件render中通过一个改变name的btn，使state中的name变化。在点击按钮的时候，state中的title没有变化，childCom渲染的内容没有改变当然是不需要再渲染的，但事实上childCom又重新渲染了 12345678render() &#123; return ( &lt;div&gt;hello,&#123;this.state.name&#125;&lt;/div&gt; &lt;button onClick=&#123;this.changeName&#125;&gt;&lt;/button&gt; &lt;childCom title = &#123;this.state.title&#125; /&gt; )&#125; ps：在react性能检测。在开发url中加上？react_perf-&gt;刷新在chrome中的performance中即可得到我们需要的性能检测的过程数据（重点看：user Timing） 这是我们就可以在子组件里通多shouldComponentUpdate来处理组件需不需要渲染。默认直接return true渲染组件。这里我们不希望子组件在父组件title没变化的时候再次渲染，这里我们就要定制一下shouldComponentUpdate 1234shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.title == this.props.title) return false return true&#125; 当然在react15之后 使用pureComponent就可以了。它的核心原理也是重写了shouldComponentUpdate 3）老生常谈key的问题 4）使用不可变的JS（immutable.js）。在这里就不细说了，具体原理就是 通过不可变得数据结构（直接比较hash值）减少我们的渲染次数。 5）如果使用了Redux。众所周知 reducer是一个纯函数，纯函数的特点就是稳定输入，稳定输出。这里我们可以用一个库（reselect）通过缓存输入过的结果，进而优化性能，程序速度。 6）React同构 SSR 首屏渲染速度 React Context：在使用react-redux的时候，我们要在最外层包裹一个Provider。把redux的store放进去。这样我们就可以在项目的任意组件中自由读取store内容了。这里用运用了context。 context是全局的，组件声明，所有子元素可以直接获取 context对数据校验强要求！(子&#x2F;父都需要设置) 这里是一个最简单的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;class Sidebar extends React.Component &#123; render () &#123; &lt;div&gt; &lt;p&gt;Top Place&lt;/p&gt; &lt;Navbar /&gt; &lt;/div&gt; &#125;&#125;class Navbar extends React.Component &#123; static contextTypes = &#123; user: PropTypes.string &#125; render () &#123; &lt;div&gt; &lt;p&gt;&#123;this.context.user&#125;のNavbar Place&lt;/p&gt; &lt;/div&gt; &#125;&#125;class Page extends React.Component &#123; static childContextTypes = &#123; user: PropTypes.string &#125; constructor (props) &#123; super(props) this.state = &#123;user: &#x27;Lac&#x27;&#125; &#125; getChildContext () &#123; return this.state &#125; render () &#123; return ( &lt;div&gt; &lt;p&gt;my name is &#123;this.state.user&#125;&lt;/p&gt; &lt;Sidebar /&gt; &lt;/div&gt; ) &#125;&#125;export default Page 以上 这两个月过得无比纠结，经验教训就是：真的没事别瞎折腾，非常累。 踏踏实实，好好工作才是真的。","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"关于直播","date":"2018-05-14T02:37:31.312Z","path":"2018/05/14/关于直播/","text":"正处于难得的空档期，五一去和大学的基友去日本的东北玩了一大圈（东京-仙台-角馆-田泽湖-秋田-弘前-青森-东京），回来也该收收心了。周末无事，浅浅的研究了一下现在大热的直播技术。同时也在这里记录一下。 直播流程（原理）PC端&#x2F;IOS&#x2F;Android -&gt; 压缩编码过程（H.264&#x2F;ACC）-&gt; 字幕叠加（视频本身处理）-&gt; 推流 -&gt; CDN -&gt; 直播（终端显示直播流） 直播协议主流的差不多就这三个：HLS协议 RTMP协议 HTTP-FLV协议 HLS协议：Apple公司推出的，暂时只支持Safari，切片格式是ts。实现原理具体就是video，它有一个M3U8索引文件。这个索引文件对应着数个ts格式的文件切片。 M3U8文件只是当前时间段的索引,segment.ts都会有个时长,在segment总时长之前,video会重新向服务器请求m3u8文件，这是浏览器自身的行为，此时，服务器会返回新的m3u8文件，更新后的segment.ts文件将会改变(m3u8文件结构并不一定全是由ts文件组成，有可能会嵌套一层m3u8文件) 对于ts文件来说：ts文件会有一个PAT的包，解析时，这个pat的包会告诉你去找一个PMT的包，PMT会告诉你后面要解析到的ts文件中，哪些是视频哪些是音频。 RTMP协议（Real Time Messaging Protocol）（实时性比较好不过使用起来比较复杂,传输的视频格式为flv） HTTP-FLV结合了HLS的优点,采用HTTP请求,又结合了RTMP低延时的特性,因为中间建立了FLV的长连接,中间通信过程相对RTMP协议就不再复杂 HTTP-FLV优点（相对RTMP): 可以在一定程度上避免防火墙干扰（有些机房只允许80端口通过） 可以很好的兼容HTTP 302跳转 可以使用HTTPS 很好的支持移动端 直播源的制作 我们需要安装Nginx，mac的话直接1brew install nginx-full --with-rtmp-module 如果安装的时候遇到 不存在的问题：brew tap denji&#x2F;nginx 换一个github源即可。 安装成功，启动Nginx，在http://localhost:8080/验证即可。 安装ffmpeg 1brew install ffmpeg 配置Nginx 12cd /usr/local/etc/nginx/code nginx.conf 123456789101112131415161718192021rtmp&#123; server &#123; listen 1935; chunk_size 4000; # RTMP 直播流配置 application rtmplive &#123; live on; max_connections 1024; &#125; # hls 直播流配置 application hls&#123; live on; hls on; hls_path /usr/local/var/www/hls; hls_fragment 5s; &#125; &#125;&#125; 12345678location /hls &#123; types&#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root /usr/local/var/www; add_header Cache-Control no-cache;&#125; 准备视频这里简单起见，在网上找一个mp4格式的测试视频模拟直播流 利用ffmpeg推流 这里分别尝试了两种协议的直播。推流方式分别是： RTMP:ffmpeg -re -i test2.mp4 -vcodec libx264 -acodec aac -f flv rtmp:&#x2F;&#x2F;localhost:1935&#x2F;rtmplive&#x2F;rtmp 使用 VLC 打开 rtmp:&#x2F;&#x2F;localhost:1935&#x2F;rtmplive&#x2F;rtmp 直播成功√ hls:ffmpeg -re -i test2.mp4 -vcodec libx264 -acodec aac -f flv rtmp:&#x2F;&#x2F;localhost:1935&#x2F;hls&#x2F;stream safar打开 http://localhost:8080/hls/stream.m3u8 直播成功√ 青森·弘前：","tags":[{"name":"直播","slug":"直播","permalink":"http://yoursite.com/tags/%E7%9B%B4%E6%92%AD/"},{"name":"HLS","slug":"HLS","permalink":"http://yoursite.com/tags/HLS/"},{"name":"RTMP","slug":"RTMP","permalink":"http://yoursite.com/tags/RTMP/"}]},{"title":"关于RN项目升级(-)","date":"2018-04-27T17:03:14.008Z","path":"2018/04/28/关于RN项目升级(-)/","text":"说道RN，依稀记得去年刚来时接触的时候还是0.38。之后公司要搞App，选了一个不新不旧的版本0.44.3。再到之后为了做一个滤镜的效果，依赖于gl-react和gl-react-native这个库。为了追究更好的体验和兼容Android机，将版本升级成了0.46.4。离职之后最近一直在看web，没怎么看RN这块。没想到现在RN已经更新到了0.55.3。（FB团队是真的勤快）,主要是闲的蛋疼。把自己的一个个人小项目升级了一波。顺便总结一下这一年RN 组件和API的变化以及升级方法。 组件上的变化：新增了：ImageBackground（背景图片组件，它是一个容器组件。当然有了它，也就不支持Image直接包裹的形式）、FlatList、SectionList、VirtualizedList（FlatList、SectionList的底层实现）、SwipeableFlatList（类似于ios备忘录从右往左划出现的效果，带滑动显示更多菜单的FlatList组件）、MaskedViewIOS（可以为组件添加一个透明的遮罩）以及为了适配ipX，0.50出现的SafeAreaView。 新增的Api：自身使用上，主要用了AccessibilityInfo（判断屏幕阅读器是否处于激活状态）以及DeviceInfo（一个类专门提供屏幕尺寸，字体缩放等信息）。YellowBox（可以屏蔽指定的警告，这个其实也很好用，0.44版本提供的。在公司项目中由于使用了code push。但是在开发环境没有配置key。每次刷新都会弹错，有了它就解决了这个问题。当然更好的办法就是在dev环境配个key）BackAndroid也被BackHandler所替换。在原有的基础上做了加强和补充。 其他： View.propTypes -&gt; ViewPropTypes takeSnapshot:从 UIManager 移动到 ReactNative(截图的话，疯狂安利：react-native-view-shot) react-navigation 代替 Navigator、NavigationExperimental。（前一阵尝试了一下 react-native-router-flux 体验也不错） 怎么升级RN一周一个版本，小版本之前有时候都跨度很大。更别提大版本0.4x-&gt;0.5x这种了。升级方式有两种： 使用react-native-git-upgrade 手动shengji 我这边比较倾向手动升级，能减少很多不必要的麻烦。使用前者是通过git自动合并更新。版本跨度较大的时候在native层各种冲突，跟头痛的一件事。手动升级这里就简单很多。可以初始化一个最新的rn项目，之后对比老项目的以来文件，进行版本改变。然后删除node_modules &amp;&amp; npm i.(当然这里要注意的就是 依赖的第三方库&#x2F;组件，一定要一个一个去检索不同版本RN对应的版本)。 除了这些之外就是： Navigator -&gt; react-navigation BackAndroid -&gt; BackHandler PropTypes -&gt; prop-types(React16开始PropTypes被迁移到了prop-types里，需要另行安装和引用) 访问修饰符protected -&gt; public View。propTypes -&gt; ViewPropTypes codePush。需要在package.json中移除依赖之后重新npm i安装 杂换了新的2017 mac pro 编译速度相比之前的15版快了很多。13k大洋不是白花的 用了新电脑，在构建rn程序的时候遇到了这个错误： 查了好半天原因，原来是新电脑没有装watchman 1brew install watchman 就好。","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"从零配置Webpack4.0搭建一个React工程","date":"2018-04-09T08:44:58.000Z","path":"2018/04/09/从零配置Webpack4.0搭建一个React工程/","text":"最近一直大部分精力都在搞App以及Node。前端这块作为初心，还是不能落下。这里不用cli。一步一步记录从零配置Webpack，来搭建起React项目。复习一下Webpack的配置。以及一些前端工程化的一些思考 前段工程化思考说道前端工程化，最重要的一个目的就是：解放生产力。对源代码进行预处理、自动打包&#x2F;自动更新页面显示、去处理图片依赖和正式环境统一这几点在开发中极大提高了开发的效率。在搭建起项目工程之后开发人员只需要关注业务&#x2F;代码即可。第二点就是保证项目质量，在多人协作，不同环境下开发。通过code lint等约束以及git commit预处理保证代码风格的一致统一，这一点对后续的代码维护很重要。第三就是优化。通过前端工程化、自动化去合理的压缩合并资源文件。这些大部分恰巧webpack帮我们完成了。在vue和react开发中，通过脚手架工具，生成项目之后，只要run一下项目就跑起来了。然而cli给我们提供的只是一个泛模板。然而我们想要去定制它、修改它。就需要深入了解它，知道他是怎么跑起来的。我想考虑的前端工程化，这是每一个前端er绕不开的话题。坑越早开越好&gt;_&lt; Webpack基础配置这里首先我们要明确webpack工程架构的核心是什么？– loader机制 （不同loader去处理不同的文件。甚至你可以自己创造一个文件，并作出对应的loader来处理它） 首先 我们npm init创建一个项目。接下来安装初始化需要的依赖： 1234npm i react --savenpm i react-dom --savenpm i webpack --savenpm i webpack-cli --save 最基本的依赖包安装完毕之后，我们需要创建WebApp的入口文件。这里我们在根目录创建一个src文件夹，并创建两个空文件app.js(作为入口文件) 以及App.jsx（声明我们app页面上的内容）。有了入口文件，就可以进行Webpack的基本配置。这里我们在根目录下创建build文件夹在下面webpack.config.js里进行配置： 12345678910111213const path = require(&#x27;path&#x27;) // 引入‘path’，为了在这里使用绝对路径，避免相对路径在不同系统时出现不必要的问题module.exports =&#123; // 应用入口 entry: &#123; app: path.join(__dirname, &#x27;../src/app.js&#x27;) // app.js作为打包的入口 &#125;, // 输出目录 output: &#123; filename: &#x27;[name].[hash].js&#x27;, //name代表entry对应的名字; hash代表 整个app打包完成后根据内容加上hash。一旦整个文件内容变更，hash就会变化 path: path.join(__dirname, &#x27;../dist&#x27;), // 打包好之后的输出路径 publicPath: &#x27;/public&#x27; // 静态资源文件引用时的路径（加在引用静态资源前面的） &#125; 有了入口和输出。我们就可以启动webpack了。这里在app.js随便写一段简单的js代码执行： 1webpack --config build/webpack.config.js --mode development 为了方便我们把这段代码加到script里： 1&quot;build&quot;: &quot;webpack --mode development --config build/webpack.config.js&quot; （Webpack4 不添加mode，会有：The ‘mode’ option has not been set. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for this environment.警告。对应option：development or production） 就会在项目根目录下多出一个dist文件夹。里面就是压缩打包好的代码 Webpack Loader基础我们要处理.jsx以及.js文件。这里我们就需要在上面的webpack.config.js加入新配置 12345678910111213141516// 配置loadermodule: &#123; rules: [ &#123; test: /.jsx$/, //使用loader的目标文件。这里是.jsx loader: &#x27;babel-loader&#x27; &#125;, &#123; test: /.(js)$/, //使用loader的目标文件。这里是.js loader: &#x27;babel-loader&#x27;, exclude: [ path.join(__dirname, &#x27;../node_modules&#x27;) // 由于node_modules都是编译过的文件，这里我们不让babel去处理其下面的js文件 ] &#125; ]&#125; 这里我们用babel-loader处理jsx文件。光在这里配置不想我们需要安装一些依赖babel-loader以及babel-core(这是babel的核心处理代码)。有了这些我们在app.js和App。jsx写一个最简单的react代码： 123456789101112131415161718//app.jsimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import App from &#x27;./App.jsx&#x27;ReactDOM.render(&lt;App /&gt;, document.body)//App.jsximport React from &#x27;react&#x27;export default class App extends React.Component &#123; render () &#123; return ( &lt;div&gt;this is app&lt;/div&gt; ) &#125;&#125; 执行一下npm run build，发现报错。这是因为我们没有进行babel的配置。在根目录加上一个.babelrc的文件 123456&#123; &quot;presets&quot;: [ [&quot;es2015&quot;, &#123;&quot;loose&quot;: true&#125;], &quot;react&quot; ]&#125; 并安装相关依赖：babel-preset-es2015、babel-preset-es2015-loose（这个是宽松模式）、babel-preset-react。 再次build，dist文件夹就会出现新打包的js文件咯 生成一个HTML这里我们想要在dist文件夹生成一个html页面去查看 我们处理过后的js代码可不可以用。这里我们需要借助’html-webpack-plugin’这个plugin 1npm i html-webpack-plugin -D 在webpack.config.js里添加 1const HTMLPlugin = require(&#x27;html-webpack-plugin&#x27;) 以及底部追加： 1234plugins: [ new HTMLPlugin() // 生成一个html页面，同时在webpack编译的时候。把我们所生成的entry都注入到这个html页面中,路径都是根据我们output配置的来走的。] 另外不要忘了 将output配置中的publicPath设为空，便于我们测试。 上面步骤走完，我们在build一下，发现dist文件夹中多出来了一个index.html文件。 打开测试一下。发现我们的chrome上出现了“this is app”的字样 ~搞定！ React服务端渲染配置现在单页面应用大行其道的年代，为了解决SEO不友好以及首屏过长的纹理。服务端渲染（SSR）也是绕不开的。react-dom是react专供web端开发渲染的工具。而服务端没有window&#x2F;document等属性：ReactDOM.render(, document.body)这句是用不了的。 下面就来说说node服务端执行环境代码在webpack下怎么搞定：首先我们需要在src目录下创建一个server渲染的入口 123456//server-entry.jsimport React from &#x27;react&#x27;import App from &#x27;./App.jsx&#x27;export default &lt;App /&gt; 之后在build中在区别开web端的webpack配置，另外创建一个新的配置文件暂且叫：webpack.config.server.js大部分内容都和web端的配置一样： 1234567891011121314151617181920212223242526272829303132const path = require(&#x27;path&#x27;) // 引入‘path’，为了在这里使用绝对路径，避免相对路径在不同系统时出现不必要的问题module.exports =&#123; target: &#x27;node&#x27;, //webpack打包出来的内容使用在什么环境下 // 应用入口 entry: &#123; app: path.join(__dirname, &#x27;../src/server-entry.js&#x27;) // app.js作为打包的入口 &#125;, // 输出目录 output: &#123; filename: &#x27;server-entry.js&#x27;, // node端没有浏览器缓存这个概念，并且需要在node中直接import这个文件。故直接命名就好 path: path.join(__dirname, &#x27;../dist&#x27;), // 打包好之后的输出路径 publicPath: &#x27;&#x27;, libraryTarget: &#x27;commonjs2&#x27; // 打包出来js模块所使用的方案（umd、amd、cmd、commonJS）这里我们使用commonjs2，适用于node端 &#125;, // 配置loader module: &#123; rules: [ &#123; test: /.(jsx)$/, //使用loader的目标文件。这里是.jsx loader: &#x27;babel-loader&#x27; &#125;, &#123; test: /.(js)$/, //使用loader的目标文件。这里是.js loader: &#x27;babel-loader&#x27;, exclude: [ path.join(__dirname, &#x27;../node_modules&#x27;) // 由于node_modules都是编译过的文件，这里我们不让babel去处理其下面的js文件 ] &#125; ] &#125;&#125; 值得注意的就是我们需要加上target和output中libraryTarget这两个配置。之后改一下我们的npm script： 1234&quot;build:web&quot;: &quot;webpack --mode development --config build/webpack.config.js&quot;,&quot;build:server&quot;: &quot;webpack --mode development --config build/webpack.config.server.js&quot;,&quot;clear&quot;: &quot;rimraf dist&quot;,&quot;build&quot;: &quot;npm run clear &amp;&amp; npm run build:web &amp;&amp; npm run build:server&quot; (rimraf是一个非常好用删除文件夹的库，当然也可以用rm的方式) 1npm run build 走一波。发现dist多出了server-entry.js这个打包好的文件。打开秋一眼，有别于web打包（是一个自执行的方法）。已经变成了node模块导出的方式咯。这里我们用express搭建一个服务，看看是否成功： 12345678910111213const express =require(&#x27;express&#x27;)const ReactSSR = require(&#x27;react-dom/server&#x27;)const serverEntry = require(&#x27;../dist/server-entry&#x27;).defaultconst app = express()app.get(&#x27;*&#x27;, (req, res) =&gt; &#123; const appStr = ReactSSR.renderToString(serverEntry) res.send(appStr)&#125;)app.listen(2333, () =&gt; &#123; console.log(&#x27;server is listening on 2333&#x27;)&#125;) react SSR这块不是这篇blog的重点就不细说。这里需要注意的是。我们的server-entry是通过export default导出的与import配套。在node中用require的方式需要require(‘..&#x2F;dist&#x2F;server-entry’).default一下这一块的知识点可以看阮一峰老师写的博文 启动服务器： chrome上出现：this is app 搞定！ 添加html模板然而我们会发现，我们通过服务端渲染出来的只是：显然不是我们想要的，二来，之前我们将直接挂在在body上其实也是不对的。这里我们迫切需要一个html模板。在src下创建一个template.html文件： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;!--app--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 更改webpack.config.js配置，在HTMLPlugin中添加选项： 123new HTMLPlugin(&#123; template: path.join(__dirname, &#x27;../src/template.html&#x27;) // 以template.html作为模板文件生成html&#125;) 因为牵扯静态文件。web端和werver端webpack的配置：输出目录中的publicPath: ‘public’ 当然app.js中就需要挂载在root节点上了。ReactDOM.render(, document.getElementById(‘root’)) 说完web端，再搞服务端。在server.js中改为： 1234567891011121314151617181920const express =require(&#x27;express&#x27;)const fs = require(&#x27;fs&#x27;)const ReactSSR = require(&#x27;react-dom/server&#x27;)const serverEntry = require(&#x27;../dist/server-entry&#x27;).defaultconst path = require(&#x27;path&#x27;)const tplPath = path.join(__dirname, &#x27;../dist/index.html&#x27;)const template = fs.readFileSync(tplPath, &#x27;utf8&#x27;) // 不指定utf-8,默认是bufferconst app = express()app.use(&#x27;/public&#x27;, express.static(path.join(__dirname, &#x27;../dist&#x27;))) //静态文件指定请求返回app.get(&#x27;*&#x27;, (req, res) =&gt; &#123; const appStr = ReactSSR.renderToString(serverEntry) res.send(template.replace(&#x27;&lt;!--app--&gt;&#x27;, appStr))&#125;)app.listen(2333, () =&gt; &#123; console.log(&#x27;server is listening on 2333&#x27;)&#125;) 因为改了之前的代码，我们需要重新build一下再启动服务 1npm run build &amp;&amp; node server/server.js 这就出来了 最后 ：告诉我们服务端渲染，需要用这个react16新加的这个方法ReactDOM.hydrate()大概意思就是如果我们使用了服务端渲染，我们需要用ReactDOM.hydrate()，在web端去渲染内容。react回去对比客户端和服务端生成的代码之间的差别。如果有差别，他会用客户端的代码替换掉服务端的代码。 123456import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import App from &#x27;./App.jsx&#x27;ReactDOM.hydrate(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 再走一波就没有警告了。 webpack-dev-serverwebpack dev server是一个通过webpack配置启动的server 配置起来也很简单。首先： 1npm i webpack-dev-server -D 之后需要判断是否为开发环境 1const isDev = process.env.NODE_ENV === &#x27;development&#x27; 将webpack.config.js中的moudle.exports,拿出来。赋值为const config之后： 12345678910111213141516171819if (isDev) &#123; config.devServer = &#123; host: &#x27;0.0.0.0&#x27;, // 我们可以允许我们用任意方式进行访问（127.0.0.1，localhost, 本机ip） port: &#x27;8888&#x27;, contentBase: path.join(__dirname, &#x27;../dist&#x27;), // hot: true, //启动热加载 overlay: &#123; // 错误提醒弹窗小遮层 errors: true //只显示error &#125;, // 和output配置对应起来 publicPath: &#x27;/public&#x27;, // 访问所有静态路径都要前面加/public才能访问生成的静态文件 historyApiFallback: &#123; index: &#x27;/public/index.html&#x27; // 所有404的请求全部访问该配置下的url &#125; &#125;&#125;module.exports = config 之后启动可以使用这条命令： 1cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js --mode development 其中cross-env也需要安装。这里他是为了解决mac下(*nix)和win环境变量设置不一致这个问题。执行完毕，http://localhost:8888/就可以使用了 Webpack3 -&gt; Webpack4一些变化不是很全，自己配置时候碰到的，不断更新中··· Webpack4之后，命令行启动都拆分开来放到了webpack-cli里。需要单独安装 webpack4加入了mode这个option。不写会有警告（development&#x2F;production） 4默认加了devtool这个选项 webpack3中webpack.optimize.CommonsChunkPlugin在4里面被废弃掉了，在config加配置，基本等同12345678// node_modules里的代码打包到vendor里optimization: &#123; spliteChunk: &#123; chunks: &#x27;all&#x27; &#125;, runtimeChunk: true&#125; 4废弃123plugins中defaultPlugins.concat([ new webpack.NoEmitOnErrorsPlugin()])","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"ReactSSR","slug":"ReactSSR","permalink":"http://yoursite.com/tags/ReactSSR/"}]},{"title":"node图片合成","date":"2018-03-09T17:12:26.000Z","path":"2018/03/10/node图片合成/","text":"最近在工作上有一个需求是在server(node.js)，将几张图片和文字合成。 经过google一番，尝试了3个库： node-images： 国人开发的一个轻量级，不需要额外安装依赖的图片处理库。可以实现图片大小，合并等功能。本打算使用它来完成需求。不过已经近一年不维护了。node 8.x版本跑步起来。看了一下issue，发现各个平台、系统的兼容性堪忧。还是不去踩这个坑了。另外其也不支持文字写入。 node-canvas：功能很强大，搜到不少Demo，没有做深入调研。应该是可以实现需求。 终于到了重点：gm。nodeJs对GraphicsMagick和ImageMagick的封装。图片处理的老牌工具，包含各种各样的功能。由于两个工具本身都不是js实现，所以需要额外安装。这里就主要说说gm。 install：在安装gm之前，我们需要安装GraphicsMagick和ImageMagickmac这里： 12brew install imagemagickbrew install graphicsmagick linux的话，拿apt-get安装就ok。 这两个安装完毕之后。在工程目录： 1npm i gm --save 就ok usage：我们现在想把图一（test.jpg)(600*600）的右下角添加图二(1.jpg)(140*140），使其合成一张图。这里 我们使用gm的draw方法。 1234567891011const gm = require(&#x27;gm&#x27;)gm(&#x27;./test.jpg&#x27;) .draw(&#x27;image Over 460, 460, 140, 140 &quot;./1.jpg&quot;&#x27;) .write(`./output/$&#123;Date.now()&#125;.jpg`, function(err) &#123; if (!err) &#123; console.log(&#x27;done&#x27;) &#125;else &#123; console.log(err.message || &quot;出错了！&quot;); &#125; &#125;) 跑一下程序，output目录下就多出来一张合成的照片咯。当然gm还有很多种合成照片的方式：compose&#x2F;mosaic&#x2F;append(api文档说的很细致这里就不展开了) gm的APi文档地址是：gm api文档 图片和图片合成很简单之后我们还想添加一段文字,查阅api我们发现有这个方法：drawText .drawText(x, y, text [, gravity]) 如果没有gravity参数，那么就将text绘制到图片中的(x,y)坐标处。如果带有gravity参数，从(x,y)坐标开始到右下角构成的图片范围内，依据gravity含义绘制文字。 gravity的选项如下： NorthWest, North, NorthEast, West, Center, East, SouthWest, South, or SouthEast 12345678910gm(&#x27;./test.jpg&#x27;) .draw(&#x27;image Over 460, 460, 140, 140 &quot;./1.jpg&quot;&#x27;) .drawText(100, 100, &#x27;wa~~~&#x27;) .write(`./output/$&#123;Date.now()&#125;.jpg`, function(err) &#123; if (!err) &#123; console.log(&#x27;done&#x27;) &#125;else &#123; console.log(err.message || &quot;出错了！&quot;); &#125; &#125;) 上述代码，我们想要在图片 左上为（0，0）。（100，100）的位置添加wa~跑一下这是报了一个错： 1Error: unable to read font `/usr/local/share/ghostscript/fonts/n019003l.pfb&#x27; @ error/annotate.c/RenderFreetype/1123: `(null)&#x27; 这是因为我们没有装ghostscript(一套建基于Adobe、PostScript及可移植文档格式（PDF）的页面描述语言等而编译成的免费软件。) 1brew install ghostscript 安装好了在执行就ok了。顺势我们再试试中文。 1.drawText(100, 100, &#x27;哇~~~&#x27;) 乱码了。google一下发现gm、GraphicsMagick的使用中，中文乱码问题屡见不鲜。解决方案总结起来就是1）utf-8编码；2）要指定中文字体库 这里我们下载了微软雅黑的ttf文件，放在根目录的font文件夹下.我们再添加一些字体属性： 123456789101112gm(&#x27;./test.jpg&#x27;) .draw(&#x27;image Over 460, 460, 140, 140 &quot;./1.jpg&quot;&#x27;) .drawText(100, 100, &#x27;哇&#x27;) .fontSize(36) .fill(&#x27;#fff&#x27;) .font(&#x27;./font/微软雅黑.ttf&#x27;) .write(`./output/$&#123;Date.now()&#125;.jpg`, function(err) &#123; if (!err) &#123;console.log(&#x27;done&#x27;)&#125;else&#123; console.log(err.message || &quot;出错了！&quot;); &#125; &#125;) 这样 白的的36号字的哇就出现在了图片上。","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"RN-CameraRoll","date":"2018-03-05T14:24:02.000Z","path":"2018/03/05/RN-CameraRoll/","text":"最近APP有一个业务需求，需要将APP中web加载出来的图片保存到本地,保存至本地相册。很方便的是RN为我们提供了CameraRoll模块，以获得去访问本地相册，以及将图片存储至相册的功能。这里我们主要用将图片存储这个功能。访问相册的话，由于CameraRoll没有提供相册UI页面以及诸多功能。要实现选取图片的话还是使用第三方的react-native-image-crop-picker微妙。基本没什么坑 CameraRoll使用起来非常简单不过需要注意的是，IOS这边需要在info.plist中添加NSPhotoLibraryUsageDescription，访问相册的权限。以及在使用该模块前你需要先链接RCTCameraRoll库(在node_modules&#x2F;react-native&#x2F;Libraries&#x2F;CameraRoll)将RCTCameraRoll工程添加到当前工程的Libraries文件夹下，然后把ibRCTCameraRoll.at加在TARGETS-&gt;Build Phaese-&gt;Link Binary With Libraries里面CameraRoll主要有三个静态方法以供使用。1.static saveImageWithTag(tag) &#x2F;&#x2F;保存一个图片到相册2.static saveToCameraRoll(tag, type?) &#x2F;&#x2F;把图片或视频保存到相册中3.static getPhotos(params: object) &#x2F;&#x2F;返回一个带有图片标识符对象的Promise 话不多说，上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import React, &#123; Component &#125; from &#x27;react&#x27;import &#123; Text, View, Image, CameraRoll, StyleSheet, Dimensions, Alert, ScrollView, TouchableOpacity&#125; from &#x27;react-native&#x27;const fetchParams = &#123; first: 6, groupTypes: &#x27;All&#x27;, assetType: &#x27;Photos&#x27;&#125;const webImgUrl = `https://tva2.sinaimg.cn/crop.0.0.750.750.180/68f74d54jw8f22cfa95ijj20ku0kumy7.jpg`export default class useLib extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; photos: [] &#125; &#125; componentDidMount () &#123; this.getPhotos() &#125; getPhotos () &#123; CameraRoll.getPhotos(fetchParams).then((data) =&gt; &#123; console.log(data) let edges = data.edges let photos = [] for (var index in edges) &#123; photos.push(edges[index].node.image.uri) &#125; this.setState(&#123; photos: photos &#125;) &#125;, (error) =&gt; &#123; Alert.alert(error) &#125;) &#125; showPics (photos) &#123; return ( &lt;View style=&#123;styles.picWrapper&#125;&gt; &#123; photos.map((result, index, arr) =&gt; &#123; return ( &lt;Image key=&#123;index&#125; style=&#123;styles.libPic&#125; source=&#123;&#123;uri: result&#125;&#125; /&gt; ) &#125;) &#125; &lt;/View&gt; ) &#125; handleClick = () =&gt; &#123; CameraRoll.saveToCameraRoll(webImgUrl) .then(data =&gt; &#123; let photos = this.state.photos photos.unshift(data) this.setState(&#123; photos: photos &#125;) &#125;) .catch(err =&gt; &#123; Alert.alert(err) &#125;) &#125; render () &#123; return ( &lt;ScrollView style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt; Get Photos &lt;/Text&gt; &#123;this.showPics(this.state.photos)&#125; &lt;Text style=&#123;styles.subTitle&#125;&gt; A Web photo &lt;/Text&gt; &lt;Image style=&#123;styles.webPic&#125; source=&#123;&#123;uri: webImgUrl&#125;&#125; /&gt; &lt;TouchableOpacity style=&#123;styles.btnWrapper&#125; onPress=&#123;this.handleClick&#125; &gt; &lt;Text style=&#123;styles.btnText&#125; &gt; Touch To Save &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/ScrollView&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &#x27;#F5FCFF&#x27; &#125;, title: &#123; alignSelf: &#x27;center&#x27;, marginTop: 30, fontSize: 24 &#125;, picWrapper: &#123; flexDirection: &#x27;row&#x27;, flexWrap: &#x27;wrap&#x27;, marginBottom: 20, width: Dimensions.get(&#x27;window&#x27;).width &#125;, libPic: &#123; width: Dimensions.get(&#x27;window&#x27;).width / 2, height: 120 &#125;, webPic: &#123; alignSelf: &#x27;center&#x27;, width: 200, height: 150 &#125;, subTitle: &#123; alignSelf: &#x27;center&#x27;, fontSize: 24 &#125;, btnWrapper: &#123; alignItems: &#x27;center&#x27;, width: Dimensions.get(&#x27;window&#x27;).width, height: 40 &#125;, btnText: &#123; fontSize: 20, color: &#x27;red&#x27; &#125;&#125;)","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"node-path","date":"2018-02-28T14:26:28.000Z","path":"2018/02/28/node-path/","text":"最近在看node，仿照anywhere，自己也撸了一个静态资源服务器。说道静态资源服务器，大量运用了路径层级这块。一开始又是相对路径，绝对路径，暴露的接口也是一大堆，有点懵逼。遂对着官方文档撸一遍，这里笔记总结一下。 path.basename(path[, ext]) path 路径 ext 可选参数 path.basename()返回路径的最后一部分 eg: 123456path.basename(&#x27;/foo/bar/baz/asdf/quux.html&#x27;);// returns &#x27;quux.html&#x27;path.basename(&#x27;/foo/bar/baz/asdf/quux.html&#x27;, &#x27;.html&#x27;);// returns &#x27;quux&#x27;path.basename(&#x27;/foo/bar/baz/asdf/quux.html&#x27;, &#x27;ux.html&#x27;);// returns &#x27;qu&#x27; path.dirname(path) path 路径 path.dirname()返回path的所在路径 eg: 123456path.dirname(&#x27;/foo/bar/baz/asdf&#x27;);// returns &#x27;/foo/bar/baz&#x27;path.dirname(&#x27;/foo/bar/baz/asdf/quux.html&#x27;);// returns &#x27;/foo/bar/baz/asdf&#x27;path.dirname(&#x27;quux.html&#x27;);// returns &#x27;.&#x27; path.extname(path) path 路径 返回路径最后一部分中的最后一个.字符到结尾截取的字符串，如果没有字符.，或者路径最后一部分的开头是字符.，则会返回空字符串。 eg: 12345678910path.extname(&#x27;index.html&#x27;)// returns &#x27;.html&#x27;path.extname(&#x27;index.coffee.md&#x27;)// returns &#x27;.md&#x27;path.extname(&#x27;index.&#x27;)// returns &#x27;.&#x27;path.extname(&#x27;index&#x27;)// returns &#x27;&#x27;path.extname(&#x27;.index&#x27;)// returns &#x27;&#x27; path.normalize(path) path 使字符串路径标准化 eg: 12345path.normalize(&#x27;/foo/bar///baz/asdf/quux/../&#x27;); // return &#x27;/foo/bar/baz/asdf/&#x27; posix // return &#x27;\\\\foo\\\\bar\\\\baz\\\\asdf\\\\&#x27; windowspath.normalize(&#x27;&#x27;); // return &#x27;.&#x27; path.join([path1][, path2][, …]) pathX 把所有字符串参数合到一起并返回标准化后的路径 eg: 123456path.join(&#x27;/foo/&#x27;, &#x27;bar&#x27;, &#x27;baz//asdf&#x27;, &#x27;quux&#x27;, &#x27;..&#x27;, &#x27;test.html&#x27;) // return &#x27;/foo/bar/baz/asdf/test.html&#x27;path.join(&#x27;/foo&#x27;, &#x27;&#x27;, &#x27;test.html&#x27;) // return &#x27;/foo/test.html&#x27; 如果有空字符串参数，则会被忽略path.join(&#x27;&#x27;) // return &#x27;.&#x27; 如果所有参数合到一起是空字符串，则会返回&#x27;.&#x27;，表示当前目录 path.isAbsolute(path) path 判断path是否是绝对路径 eg: 1234567891011// Posixpath.isAbsolute(&#x27;/foo/bar&#x27;) // truepath.isAbsolute(&#x27;/baz/..&#x27;) // truepath.isAbsolute(&#x27;qux/&#x27;) // falsepath.isAbsolute(&#x27;.&#x27;) // false// Windowspath.isAbsolute(&#x27;//server&#x27;) // truepath.isAbsolute(&#x27;C:/foo/..&#x27;) // truepath.isAbsolute(&#x27;bar\\\\baz&#x27;) // falsepath.isAbsolute(&#x27;.&#x27;) // false path.format(pathObject)根据参数pathObject返回路径字符串。 eg: 12345678910111213141516171819202122232425262728293031// If `dir` and `base` are provided, `dir` + platform separator + `base`// will be returned.path.format(&#123; dir: &#x27;/home/user/dir&#x27;, base: &#x27;file.txt&#x27;&#125;);// returns &#x27;/home/user/dir/file.txt&#x27;// `root` will be used if `dir` is not specified.// `name` + `ext` will be used if `base` is not specified.// If only `root` is provided or `dir` is equal to `root` then the// platform separator will not be included.path.format(&#123; root: &#x27;/&#x27;, base: &#x27;file.txt&#x27;&#125;);// returns &#x27;/file.txt&#x27;path.format(&#123; dir: &#x27;/&#x27;, root: &#x27;/&#x27;, name: &#x27;file&#x27;, ext: &#x27;.txt&#x27;&#125;);// returns &#x27;/file.txt&#x27;// `base` will be returned if `dir` or `root` are not provided.path.format(&#123; base: &#x27;file.txt&#x27;&#125;);// returns &#x27;file.txt&#x27; path.parse(pathString)和path.format相反 eg: 123456789path.parse(&#x27;/home/user/dir/file.txt&#x27;)// returns// &#123;// root : &quot;/&quot;,// dir : &quot;/home/user/dir&quot;,// base : &quot;file.txt&quot;,// ext : &quot;.txt&quot;,// name : &quot;file&quot;// &#125; path.relative(from, to)该方法根据两个绝对路径from和to解析出一个相对路径（说白了就是从一个绝对路径到另一个绝对路径是怎么走的） eg: 12path.relative(&#x27;/data/orandea/test/aaa&#x27;, &#x27;/data/orandea/impl/bbb&#x27;)// returns &#x27;../../impl/bbb&#x27; path.resolve([from …], to)简单讲就是执行一连串的cd命令，执行后返回一个绝对路径 eg: 12345cd foo/barcd /tmp/file/cd ..cd a/../subfilepwd","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node服务器开发上线小记","date":"2018-02-06T14:20:56.000Z","path":"2018/02/06/node服务器开发上线小记/","text":"说道node，之前其实也没少用。不过大部分都是自己搞着玩，写个小爬虫或是在本地为自己的前端项目跑个接口。实际开发生产中经验为零。正巧工作中自己负责的APP项目的新模块后台要独立出来，借此机会使用走了一趟node开发到上线的全过程（express+mongoDB）。 开发新模块开始的功能不太多，开发这块没有花太多时间。不过还是有一些值得记录的地方： 摒弃callback，拥抱async&#x2F;promisify。 node在8.X.X版本之后支持了async以及promisify的方式。callback hole确确实实令人不爽使用async或者util.promisify会让代码优雅很多。 import代替require 在最新的node v9.5.0，依然没有支持这一特性。我们引入文件还是需要通过require的方式。虽然不是很推荐，不过执意要在node中使用import这一特性的话。需要安装babel-cli，进行转换 。 处理图片存储这一块 公司用的图片存储用的是又拍云。这里需要的是，将图片上传至又拍云，得到云上的图片地址，进而存储到数据库中。期初想的是在前端完成上传又拍云得到图片地址这一系列操作。后端只接收图片地址这一个字符串，进行存储。虽说是有相关JS SDK。不过前端终究不安全，有一些生成密锁&#x2F;token之类的操作。还是通过form-data传到服务器这边进行操作符合逻辑。这里遇到了一个小问题node这边怎么接受图片。经过一番尝试，这里使用了multer这个中间件。拿到form表单传过来的图片。 log 服务器当然要有log。这里使用了另一个中间件：log4js。 123456789101112// LOG配置log4js.configure(&#123; appenders: [&#123; type: &#x27;dateFile&#x27;, filename: &#x27;logs/access.log&#x27;, pattern: &#x27;-yyyy-MM-dd.log&#x27;, alwaysIncludePattern: true, category: &#x27;access&#x27; &#125;]&#125;)// Log Middlewareapp.use(log4js.connectLogger(log4js.getLogger(&#x27;access&#x27;), &#123; level: log4js.levels.INFO &#125;)) 这里部署上线的时候，其实还遇到了一个小问题。官方例子中type: ‘Date File’。在服务器上执行。报错！查了一下issue，改成小写d，搞定。 mongoDB 又是一个部署服务器上出现的问题。在本地使用mongoDB没有设置相关的权限账号。服务器上运维给我了一个admin的root账号。一开始不太懂尝试连接建model。出了一大堆权限问题。和传统数据库不同： 1 MongoDB是没有默认管理员账号的，所以要先添加管理员账号，在开启权限认证。 2 切换到admin数据库，添加的账号才是管理员的账号。 3 用户只能在用户所在的数据库登录，包括管理员账号。 4 管理员可以管理所有的数据库，但是不能直接管理其它数据库，要先在admin数据库中认证才可以，也是为了 安全性考虑。 具体操作如下： 这里需要先通过mongo命令使用账号、密码连接线上的mongo。注意这里必须指定admin model。 12mongo --username XXX --password XXX mongoDB线上地址/admin 之后通过use DATEBASE_NAME (use 如果数据库不存在，则创建数据库,否则切换到指定数据库） show dbs看看创建成功没有。之后 1234567db.createUser( &#123; user: &quot;lac&quot;, pwd: &quot;123321&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;XXX&quot; &#125; ] &#125;) 通过上面的命令 创建一个对应数据库，拥有读写权限的用户。 在node中，这样使用就好 1mongodb: &#x27;mongodb://lac:123321@mongoDB线上地址:端口/所使用的DB名字&#x27; 搞明白了很简单。当时倒腾了好一阵orz 413错误 上线之后，上传图片&#x2F;数据。response返回了413错误 Request Entity Too Large。这里是由于服务器限制了上传文件的大小，解决办法就是： 在nginx.conf里http{}中加入： 1client_max_body_size 20m ; 允许最大上传的大小设为20m。之后重启nginx即可。 pm2 线上部署运行node 使用的是pm2 一些常用命令： 1234567891011121314151617181920212223 $ pm2 start app.js # 启动app.js应用程序$ pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 &quot;api&quot;$ pm2 start app.js --watch # 当文件变化时自动重启应用$ pm2 start script.sh # 启动 bash 脚本$ pm2 list # 列表 PM2 启动的所有的应用程序$ pm2 monit # 显示每个应用程序的CPU和内存占用情况$ pm2 show [app-name] # 显示应用程序的所有信息$ pm2 logs # 显示所有应用程序的日志$ pm2 logs [app-name] # 显示指定应用程序的日志pm2 flush$ pm2 stop all # 停止所有的应用程序$ pm2 stop 0 # 停止 id为 0的指定应用程序$ pm2 restart all # 重启所有应用$ pm2 reload all # 重启 cluster mode下的所有应用$ pm2 gracefulReload all # Graceful reload all apps in cluster mode$ pm2 delete all # 关闭并删除所有应用$ pm2 delete 0 # 删除指定应用 id 0$ pm2 scale api 10 # 把名字叫api的应用扩展到10个实例$ pm2 reset [app-name] # 重置重启数量 以上~","tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://yoursite.com/tags/mongoDB/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"一个小总结","date":"2018-01-27T15:19:50.000Z","path":"2018/01/28/一个小总结/","text":"12月底本就打算在这里总结一下自己，工作生活上一堆事再加上工作上的一堆总结：个人总结、小组总结以及小组述职。自己这块一直偷懒没有写，拖到了今天。 回顾2017，那一个字总结就是：变 加入了新公司：无二之旅是变；技术上从后端到前端再到现在用RN开发移动端是变；再有就是自己心境的变化，在日本的时候无忧无虑，到现在的焦躁也是变。 在日本的时候无忧无虑，在那个大环境下也不用去想什么。回来之后，北京这个焦躁过度的城市，大家都在跑，你也不得不跑。压力也随之而来。很怀念在日本的日子。但经过努力再回头，真的是成长了不少。收获了很多经验和新技术，感觉自己也不像原来一下わがまま，成熟了很多。18年，不知道会怎么样，但希望自己越变越好。少一些焦躁，遇事，慢慢来。身体管理17年做的不太好，这一年胖了好多，18年多抽出来一点时间锻炼一下。毕竟身体是革命的本钱。 再立几个FLAG： 坚持github everday； 开春之后，捡起跑步大业 多看书 调整心态，更从容一点 17年没怎么出去玩，就10月回了趟东京。18年起码出去5次吧。（2月马来西亚、3月泰国、5月日本已经确定了） 就这样吧~","tags":[{"name":"2017","slug":"2017","permalink":"http://yoursite.com/tags/2017/"}]},{"title":"Mongoose用法笔记","date":"2018-01-09T15:23:04.000Z","path":"2018/01/10/Mongoose用法笔记/","text":"本来新年第一篇博文理应是2017年的总结。客观+主观原因，一直拖着难产不出。近期工作这边有需求，APP这块一个独立的业务搭建一个迷你小后台。既然是迷你小后台，应该找不出Express+Mongo以外更好的选择了吧。node和mongo结合，最通用的就是mongoose这个库，操作使用都很便利，简单。在这里笔记总结一下 首先需要npm install mongoose 安装mongoose，安装成功后就可以通过require(‘mongoose’) 来使用！ Connect12345678910111213141516171819202122232425262728var mongoose = require(&#x27;mongoose&#x27;), DB_URL = &#x27;mongodb://localhost:27017/mongoosesample&#x27;;/** * 连接 */mongoose.connect(DB_URL);/** * 连接成功 */mongoose.connection.on(&#x27;connected&#x27;, function () &#123; console.log(&#x27;Mongoose connection open to &#x27; + DB_URL); &#125;); /** * 连接异常 */mongoose.connection.on(&#x27;error&#x27;,function (err) &#123; console.log(&#x27;Mongoose connection error: &#x27; + err); &#125;); /** * 连接断开 */mongoose.connection.on(&#x27;disconnected&#x27;, function () &#123; console.log(&#x27;Mongoose connection disconnected&#x27;); &#125;); Schema schema是mongoose里会用到的一种数据模式，可以理解为表结构的定义；每个schema会映射到mongodb中的一个collection，它不具备操作数据库的能力 12345 var userSchema = new mongoose.Schema(&#123; name: &#123;type: String, require: true&#125;, age: &#123;type: Number, require: true&#125;&#125;)) 定义一个Schema就这么简单~ Schema Types内置类型如下： String Number Boolean | Bool Array Buffer Date ObjectId | Oid Mixed 定义好Schema，接下就是生成Model。model是由schema生成的模型，可以对数据库的操作1const User = mongoose.model(&#x27;user&#x27;, userSchema) 常用数据库操作插入 Model#save([fn]) 12345678910111213141516// insert function insert () &#123; var user = new User(&#123; name: &#x27;yoyo&#x27;, age: 66 &#125;) user.save(function(err, doc) &#123; if (err) &#123; console.log(&quot;Error:&quot; + err); &#125; else &#123; console.log(&quot;Doc:&quot; + doc); &#125; &#125;) 更新 Model.update(conditions, update, [options], [callback]) 123User.update(&#123;&#x27;name&#x27;: &#x27;yoyo&#x27;&#125;, &#123;&#x27;$set&#x27;: &#123;age: 26&#125;&#125;, function(err, doc) &#123;console.log(doc)&#125;) update方法基本可以满足所有更新！常用方法还有findByIdAndUpdate，这种比较有指定性，就是根据_idModel.findByIdAndUpdate(id, [update], [options], [callback]) 123456789101112131415function findByIdAndUpdate()&#123; var id = &#x27;56f2558b2dd74855a345edb2&#x27;; var updatestr = &#123;&#x27;name&#x27;: &#x27;yoyoyo&#x27;&#125;; User.findByIdAndUpdate(id, updatestr, function(err, res)&#123; if (err) &#123; console.log(&quot;Error:&quot; + err); &#125; else &#123; console.log(&quot;Res:&quot; + res); &#125; &#125;)&#125;findByIdAndUpdate(); 其他的更新方法：Model.findOneAndUpdate([conditions], [update], [options], [callback]) &#x2F;&#x2F;找到一条记录并更新 删除 Model.remove(conditions, [callback]) 1User.remove(&#123;&#125;,function (e, d) &#123;&#125;) res中会返回是否成功以及影响的行数：{“ok”:1,”n”:1} 还有其他删除： Model.findByIdAndRemove(id, [options], [callback]) Model.findOneAndRemove(conditions, [options], [callback]) 查 Model.find(conditions, [fields], [options], [callback]) 123User.find(&#123;name: &#x27;zyy&#x27;&#125;, function(err, doc) &#123; res.json(doc)&#125;) 第2个参数可以设置要查询输出的字段,比如改成: 1234var opt = &#123;&quot;name&quot;: 1 ,&quot;_id&quot;: 0&#125;;User.find(&#123;name: &#x27;zyy&#x27;&#125;, opt, function(err, doc) &#123; res.json(doc)&#125;) 输出只会有name字段，设置方法如上，1表示查询输出该字段，0表示不输出 比如我要查询年龄范围条件应该怎么写呢？ User.find({userage: {$gte: 21, $lte: 65}}, callback); &#x2F;&#x2F;这表示查询年龄大于等21而且小于等于65岁 类似的其他： $or 或关系 $nor 或关系取反 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $ne 不等于 $in 在多个值范围内 $nin 不在多个值范围内 $all 匹配数组中多个值 $regex 正则，用于模糊查询 $size 匹配数组大小 $maxDistance 范围查询，距离（基于LBS） $mod 取模运算 $near 邻域查询，查询附近的位置（基于LBS） $exists 字段是否存在 $elemMatch 匹配内数组内的元素 $within 范围查询（基于LBS） $box 范围查询，矩形范围（基于LBS） $center 范围醒询，圆形范围（基于LBS） $centerSphere 范围查询，球形范围（基于LBS） $slice 查询字段集合中的元素（比如从第几个之后，第N到第M个元素） 可能还有一些，没什么印象，大家自行看看api ^_^! 数量查询 Model.count(conditions, [callback]) 123456789101112131415function getCountByConditions()&#123; var wherestr = &#123;&#125; User.count(wherestr, function(err, res)&#123; if (err) &#123; console.log(&quot;Error:&quot; + err); &#125; else &#123; console.log(&quot;Res:&quot; + res); &#125; &#125;)&#125;getCountByConditions() 其他的一些东西：根据_id查询 Model.findById(id, [fields], [options], [callback]) 模糊查询： 1234567891011121314151617var User = require(&quot;./user.js&quot;);function getByRegex()&#123; var whereStr = &#123;&#x27;username&#x27;:&#123;$regex:/m/i&#125;&#125;; User.find(whereStr, function(err, res)&#123; if (err) &#123; console.log(&quot;Error:&quot; + err); &#125; else &#123; console.log(&quot;Res:&quot; + res); &#125; &#125;)&#125;getByRegex(); 上面示例中查询出所有用户名中有’m’的名字，且不区分大小写，模糊查询比较常用，正则形式匹配，正则方式就是javascript正则，用到的比较多！ 常用的其他方法 Model.distinct(field, [conditions], [callback]) &#x2F;&#x2F;去重 Model.findOne(conditions, [fields], [options], [callback]) &#x2F;&#x2F;查找一条记录 Model.findOneAndRemove(conditions, [options], [callback]) &#x2F;&#x2F;查找一条记录并删除 Model.findOneAndUpdate([conditions], [update], [options], [callback]) &#x2F;&#x2F;查找一条记录并更新 以上~","tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://yoursite.com/tags/mongoDB/"}]},{"title":"React代码整洁之道笔记","date":"2017-12-07T15:31:58.000Z","path":"2017/12/08/React代码整洁之道笔记/","text":"因为RN开始接触React，JSX相比HTML，更加简明。由于All in JS，如果在编写React代码的时候不注重代码的规范和整洁。后期维护起来会相当的痛苦。 正如文章所说:编程也是艺术行为，当我们丝毫代码复用、变量命名时，就是在进行艺术的思考。 不冗余123456789101112131415161718// Dirtyconst MyComponent = () =&gt; ( &lt;div&gt; &lt;OtherComponent type=&quot;a&quot; className=&quot;colorful&quot; foo=&#123;123&#125; bar=&#123;456&#125; /&gt; &lt;OtherComponent type=&quot;b&quot; className=&quot;colorful&quot; foo=&#123;123&#125; bar=&#123;456&#125; /&gt; &lt;/div&gt;);// Cleanconst MyOtherComponent = (&#123; type &#125;) =&gt; ( &lt;OtherComponent type=&#123;type&#125; className=&quot;colorful&quot; foo=&#123;123&#125; bar=&#123;456&#125; /&gt;);const MyComponent = () =&gt; ( &lt;div&gt; &lt;MyOtherComponent type=&quot;a&quot; /&gt; &lt;MyOtherComponent type=&quot;b&quot; /&gt; &lt;/div&gt;); 但是要记住不要过度的优化，拆分。过度和破坏没什么区别。 可预测、可测试这方面自己接触的不是很多，抽空有必要好好学习一下前端方面的测试 自我解释 斟酌变量名尽可能减少代码中的注释。可以通过让变量名更语义化、只注释复杂、潜在逻辑，来减少注释量，同时也提高了可维护性，毕竟不用总在代码与注释之间同步了。 布尔值或者返回值是布尔类型的函数，命名以 is has should 开头 函数以其效果命名，而不是怎么做的来命名eg：1234567891011121314// Dirtyconst done = current &gt;= goal;// Cleanconst isComplete = current &gt;= goal;// Dirtyconst loadConfigFromServer = () =&gt; &#123; ...&#125;;// Cleanconst loadConfig = () =&gt; &#123; ...&#125;; 遵循设计模式这里所说的设计模式并不是工程上的，而是更广泛开发中的设计模式。比如使用standrad进行代码规范··· 对于 React，遵循以下几个最佳实践： 单一责任原则, 确保每个功能都完整完成一项功能，比如更细粒度的组件拆分，同时也更利于测试。 不要把组件的内部依赖强加给使用方。 lint 规则尽量严格。 总结编写整洁规范的代码，也许在一开始的时候会放慢开发速度，因为你需要转变自己的思维模式，但随着不断迭代，它的带来的效率提升会逐渐弥补前面的损失，并不断带来开发效率的提升。 最开始自己写RN的时候，需求来的急，用脚写固然可以快速完成。之后在维护的时候，就很痛苦不得不重构代码。自己非常喜欢函数式编程。很羡慕函数式工作环境的开发者，他们几乎只要为每个功能写一遍，剩下的就是记住并调用它。 以上~","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"Express配合MongoDB简单使用","date":"2017-12-06T14:07:08.000Z","path":"2017/12/06/Express配合MongoDB简单使用/","text":"快速开发一个web接口，应该没有比Express+mongoDB更快&#x2F;更简单的组合了。这里简单总结一些使用nodeJs的mongoose模块链接和操作mongoDB。 Express:基于nodejs快速、开放、极简的web开发框架,怎么安装就不在赘言。这里要说的是如果使用node命令启动server，每次修改文件都需要Ctrl+c非常麻烦。这里可以使用nodemon自动重启，监听路由和响应内容.十分方便 1npm install -g nodemon Express的一些特性： app.get、app.post分别开发get和post接口 app.use使用模块 res.send、res.json、res.sendfile响应不同的内容 使用起来非常简单，半个小时不到就能上手 mongoDBMac的话,安装mongoDB非常简单 1brew install mongodb 搞定. 通过命令后台启动 1mongod --config /usr/local/etc/mongod.conf 之后再开一个终端窗口 就证明mongo安装成功咯。 之后就是安装mongoose。mongoDB和node配合最好的一个库。说通俗一点：通过mongoose操作mongobd，存储的就是json，相对mysql来说，要易用很多。 1npm install mongoose --save mongoose的使用 connect链接数据库 1234567const mongoose = require(&#x27;mongoose&#x27;)// 链接mongoconst DB_URL = &#x27;mongodb://127.0.0.1:27017&#x27;mongoose.connect(DB_URL)mongoose.connection.on(&#x27;connected&#x27;,function () &#123; console.log(&#x27;mongo connect success&#x27;)&#125;) 如果node server端打印出：mongo connect success。mongoDB就链接上了 定义文档模型，Schema和model新建模型 代一个数据库文档对应一个模型，通过模型对数据库进行操作 eg： 1234const User = mongoose.model(&#x27;user&#x27;, new mongoose.Schema(&#123; name: &#123;type: String, require: true&#125;, age: &#123;type: Number, require: true&#125;,&#125;)) Mongoose文档类型： String、Number等数据结构 定create、remove、update分别用来增删改查的操作 Find和findOne用来查询数据 新增数据： 123456789101112// 新增数据User.create(&#123; name: &#x27;lac&#x27;, age: 20&#125;, function (err, doc) &#123; if (!err) &#123; console.log(doc) &#125; else &#123; console.log(err) &#125;&#125;) 删除数据： 123456// 删除数据User.remove(&#123;age: 20&#125;, function (err, doc) &#123; if (!err) &#123; console.log(doc) &#125;&#125;) 查询数据 123User.find(&#123;name: &#x27;lac&#x27;&#125;,function (err, doc) &#123; res.json(doc)&#125;) findOne就是查找到一条返回~，find是多条。 更新数据 1234// 更新User.update(&#123;&#x27;name&#x27;: &#x27;lac&#x27;&#125;,&#123;&#x27;$set&#x27;: &#123;age: 26&#125;&#125;,function (err, doc) &#123; console.log(doc)&#125;)","tags":[{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"CSS混合模式","date":"2017-11-18T13:39:04.000Z","path":"2017/11/18/CSS混合模式/","text":"前几天在一个一个技术网站看到了一篇通过CSS3特性，完成酷炫效果的文章。在公司搞App移动端以来，好一阵没有写纯粹的html和css了。今儿学到了一个以前不知道的CSS3属性：混合模式。 关于混合模式CSS3出现了两个与混合模式有关的属性，mix-blend-mode和background-blend-mode. 兼容性如下：可见，Chrome和FireFox已经支持了，并且不需要使用前缀。 mix-blend-mode可使用的值： 1234567891011121314151617181920mix-blend-mode: normal; //正常mix-blend-mode: multiply; //正片叠底mix-blend-mode: screen; //滤色mix-blend-mode: overlay; //叠加mix-blend-mode: darken; //变暗mix-blend-mode: lighten; //变亮mix-blend-mode: color-dodge; //颜色减淡mix-blend-mode: color-burn; //颜色加深mix-blend-mode: hard-light; //强光mix-blend-mode: soft-light; //柔光mix-blend-mode: difference; //差值mix-blend-mode: exclusion; //排除mix-blend-mode: hue; //色相mix-blend-mode: saturation; //饱和度mix-blend-mode: color; //颜色mix-blend-mode: luminosity; //亮度mix-blend-mode: initial; //初始mix-blend-mode: inherit; //继承mix-blend-mode: unset; //复原 有了mix-blend-mode，我们能更方便的使用一些文字特效。 * mix-blend-mode默认情况下是会混合所有比起层叠顺序低的元素的，如果我们希望值混合某一两个元素，而不是全部，该怎么办呢？可以试试使用CSS3 isolation:isolate background-blend-mode顾名思义 背景混合，属性支持和mix-blend-mode一致，需要注意的是，只能是background属性中的背景图片和颜色混合，而且只能在一个background属性中。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"比Redux简单太多的Mobx","date":"2017-11-18T13:30:54.000Z","path":"2017/11/18/比Redux简单太多的Mobx/","text":"unhappy with redux? try mobx 相比上手&#x2F;操作及其繁琐的Redux，用Mobx做状态管理，最直观的感受是爽爆了。 Mobx是一个非常直观的状态管理库，使用非常简单。通过Mobx，使react 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。 废话不多说，这里通过一个最最简单的例子来感受基于RN的Mobx。 首先init 一个RN工程： 1react-native init ReactNativeMobX 安装依赖库mobx以及mobx-react： 1npm i mobx mobx-react --save 因为mobx要使用ES7的语法（Decorator）,我们还需要在项目中使用babel： 1npm i babel-plugin-transform-decorators-legacy babel-preset-react-native-stage-0 --save-dev 在工程目录下的.babellrc文件里配置一下： 1234&#123; &quot;presets&quot;: [&quot;react-native&quot;], &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]&#125; 环境搭配完咯。下面我们就可以编写代码咯。这里实现一个超级简单的例子。两个btn，+和-。控制字符的加减。 首先，我们在工程根目录创建一个mobx文件夹并创建一个仓库文件：countStore.js 1234567891011121314151617181920212223242526// 导入了被观察者 observableimport &#123;observable&#125; from &#x27;mobx&#x27;// 创建了一个新类：ObservableCountStoreclass ObservableCountStore &#123; // 定义一个data变量。这个变量的特殊之处在于被@observable修饰 // 表示该类的data属性可被观察者（observer）观察，也就是观察者模式。 @observable data = 0 // 递增操作方法 handleAdd = () =&gt; &#123; this.data++ &#125; // 递减操作方法 handleDec = () =&gt; &#123; this.data-- &#125;&#125;// 实例化了ObservableListStore类const observableCountStore = new ObservableCountStore();// export实例化的对象export default observableCountStore 这里我们的仓库就创建完了。接下来在App.js文件（新版RN将index.android.js及index.ios.js合二为一了）使用我们的store。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; StyleSheet, Text, View, TouchableOpacity&#125; from &#x27;react-native&#x27;;// 导入observer（观察者）import &#123;observer&#125; from &#x27;mobx-react/native&#x27;// 导入我们的仓库import observableCountStore from &#x27;./mobx/countStore&#x27;// 我们使用@observer修饰符来修饰App类，它可以保证当其相关联的数据变化时，该组件会重新渲染@observerexport default class App extends Component&lt;&#123;&#125;&gt; &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; &#123;observableCountStore.data&#125; &lt;/Text&gt; &lt;View style=&#123;styles.wrapper&#125; &gt; &lt;TouchableOpacity style=&#123;styles.countBtn&#125; onPress=&#123;() =&gt; &#123; observableCountStore.handleAdd() &#125;&#125; &gt; &lt;Text&gt;+&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;styles.countBtn&#125; onPress=&#123;() =&gt; &#123; observableCountStore.handleDec() &#125;&#125; &gt; &lt;Text&gt;-&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;// 样式省略~ 通过observableCountStore.data，在render里使用store里的数据。通过observableCountStore.handleAdd()和observableCountStore.handleDec()两个方法来改变状态。 至此一个最最简单的Mobx例子完成。我们可以看到mobx以最直接的方式来管理我们的状态，即我们开始说的 mobx 关注的是状态仓库（store）到的状态(state)的问题。是不是比Redux简单太多了~&#x3D;。&#x3D;","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"},{"name":"Mobx","slug":"Mobx","permalink":"http://yoursite.com/tags/Mobx/"}]},{"title":"函数式编程与Redux","date":"2017-11-14T15:13:40.000Z","path":"2017/11/15/函数式编程与Redux/","text":"说道函数式编程，JS这边Redux是代表中的代表。 以Redux的reducers函数为例，它是标准的纯函数，这里举个最简单的例子，说明为什么要用纯函数： 首先是源码 1234567891011121314151617181920212223242526272829unction posts( state = &#123; isFetching: false, didInvalidate: false, items: [] &#125;, action) &#123; switch (action.type) &#123; case INVALIDATE_SUBREDDIT: return Object.assign(&#123;&#125;, state, &#123; didInvalidate: true &#125;) case REQUEST_POSTS: return Object.assign(&#123;&#125;, state, &#123; isFetching: true, didInvalidate: false &#125;) case RECEIVE_POSTS: return Object.assign(&#123;&#125;, state, &#123; isFetching: false, didInvalidate: false, items: action.posts, lastUpdated: action.receivedAt &#125;) default: return state &#125;&#125; 如果我们不用return，在reducer内修改旧的state变量。变为不纯的函数，是这样的。 123456789101112131415161718192021switch (action.type) &#123; case INVALIDATE_SUBREDDIT: state = Object.assign(&#123;&#125;, state, &#123; didInvalidate: true &#125;) case REQUEST_POSTS: state = Object.assign(&#123;&#125;, state, &#123; isFetching: true, didInvalidate: false &#125;) case RECEIVE_POSTS: state = Object.assign(&#123;&#125;, state, &#123; isFetching: false, didInvalidate: false, items: action.posts, lastUpdated: action.receivedAt &#125;) default: return state&#125; 在Redux中combineReducers.js中看下redux是如何处理的 12345678910111213141516 let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === &#x27;undefined&#x27;) &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state&#125; 这两行 1const nextStateForKey = reducer(previousStateForKey, action) 1hasChanged = hasChanged || nextStateForKey !== previousStateForKey reducer将旧的状态（prev）和要修改的数据一起传进去，然后返回一个新的（next）状态，prev和next相比较来确定storge数据是否改变。如果我们用不纯的函数，prev和next将一致，就算数据改变，hasChanged也会是false。通过函数式的方式没有什么“副作用” Redux全篇都是函数式编程，这里只是冰山一角。Redux的源码写得非常优雅。","tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Swift学习杂记(一)","date":"2017-11-04T16:07:52.000Z","path":"2017/11/05/Swift学习杂记(一)/","text":"半路出家搞RN，还是有必要学习学习原生的东西，最近在看Swift语法。这里杂乱的记一下。 （2017.11.3 ·水立方） let关键字和var关键字分别表示常量和变量 Swift是一种let关键字和var关键字分别表示常量和变量 Swift是一种非常简洁的语言，其允许开发者省略分号，自动换行来分割语句，同事也支持在一行中编写多句代码 如果需要改变变量的值，直接对变量再赋值即可。需要注意：所复制的类型必须和变量的类型保持一致。 swift语言的注释一个有趣的特性：可以进行注释的嵌套 12345//单行注释//注释中的注释/*多行注释 /*嵌套注释*/*/ swift整数数据分有符号整数类型和无符号整数类型。 swift一个十分有意思的特性：无论是整数数据还是浮点数据。都可以在数字前加任意的0来进行位数填充，也可以在数字中加入下划线_进行分割，今儿增加可读性。 swift的BOOLl类型十分严格。只有true和false两种值。 swift元祖：允许一些不相关的类型进行自由组合成为新的集合类型。OC并不支持这种数据类型。 swift语言中常常使用“_”来表示匿名的概念，因此“_”也被称为匿名标识符 Swift语言中提供了一种包装的方式来对普通类型进行Optional包装，实现对空值情况的监控。。在swift语言中如果使用了一个没有进行复制的变量，程序是会直接报错终止的。 在普通类型后面添加符号“？”，既可以将普通配型包装为Optional类型。 optional类型不会独立存在，其总是会附着于某个具体的数据类型之上。 Optional类型是对普通类型的一种包装，因此在使用的时候也需要对其进行拆包操作。 12345//声明obj为String?类型var obj:Srting? = &quot;HS&quot;if obj != nil &#123; obj!&#125; 为变量起别名：typealias Swift是一种弱化指针的语言，它提供了String和Character类型来描述字符串与字符。 Swift语言有3种集合类型：Array，Set，Dictionary 字符串组合：除了+进行字符串拼接。swift提供了一种十分便捷的字符串插值方法。 123// 使用\\()进行字符串插值var d = &quot;Hello \\(123)&quot; //&quot;Hello 123&quot; Swift语言中可以使用MemoryLayout枚举来获取某个类型所占的内存空间，其单位为字节： 1MemoryLayout&lt;String&gt;.size //24字节 判断字符串变量是否为空： 12obj1.isEmptyobj1.characters.count == 0 1234// 获取字符串起始下标var stringIndex = string.startIndex// 结束下标var endIndex = string.endIndex 注意：除非为空字符，否则结束下标志总会比字符串中最后一个字符的下标值大1；另外startIndex和endIndex获取到的值是index类型，并不是整数类型 检查字符串前后缀： 1234// 检查字符串是否有MY前缀string2.hasPrefix(&#x27;MY&#x27;)// 检查字符串是否有jaki后缀string2.hasSuffix(&quot;jaki&quot;) Swift语言中Array采用结构体来实现，对于大量重复元素的数组，可以使用： 12// 创建是个“Hello”元素的数组var arr = [String](repeating: &quot;Hello&quot;,count: 10) *只有当Array实例为变量的时候才可以使用增删改查等方法。常量let不行。 Array实例中有一个enumerated()的方法，这个方法会返回一个元祖集合，将数组的下标和对应元素返回。 Array排序函数：sort(isOrderedBefore:)的方式进行排序。 12345var arr = [1,3,5,7]//从大到小arr.sorted(isOrderedBefore: &gt;)//从小到大arr.sorted(isOrderedBefore: &lt;) Set一个独有的的点可以进行数学的集合运算：交集、并集、补集等 Set虽然不强调顺序。但是可以先排序再遍历 1234for item in set1.sorted(isOrderedBefore: &gt;) &#123; print(item)&#125; Swift字典类型：通过[param1:param2]这种结构用于表示字典类型，或者Dictionary&lt;Int，String&gt;这种方式。 区间运算：swift支持Range结构体来描述范围外，还可以这样： 1234// 创建范围大于等于0，小于等于10var range1 = 0...10// 大于等于0，小于10.半开闭var range2 = 0..&lt;10 通过~&#x3D;来检查某个数字是否包含在范围中 1print(range1 ~= 8) Swift提供了for-in,while,repeat-while三种循环结构 12345// 如果不需要获取循环中的次序，可以使用匿名函数的方式var sum = 0for _ in 1...3 &#123; sum += 1&#125; 生成随机数 123//1~7// arc4random()为Swift标准库中的随机数生成函数var rand = arcrrandom() % 7 + 1 闭包和函数闭包和函数有着密不可分的关系：函数是有名称的功能代码块，闭包在绝大多数情况是没有名称的功能代码块。swift的函数格式： 1func 函数名(p1,p2...) -&gt;returnValue &#123;实现部分&#125; 如果函数也不需要返回值，可以选择返回Void或者直接省略掉返回值部分。 Swift语言中有一个使用技巧，开发者可以通过Optional类型来标识函数的执行是否成功。在调用函数时使用if-let进行安全检查。eg： 123456789func onMyOMG(param: Int) -&gt; Int? &#123; guard param &gt; 100 else &#123; return nil &#125; return param - 100&#125;if let temp = ohMyOMG(param: 101) &#123; print(temp)&#125; Swift语言的参数传递，有一个特点：传递的如果是值类型的参数，那么参数值在传递进函数内部时会将原值拷贝为一份常量。且在函数内不能修改。 Any在Swift语言中代表任意类型 Swift语言中创建数值变量时可以通过+“0b”前缀的方式讲数值设为二进制 swift使用enum关键词来进行枚举的创建 结构体 枚举以及之前提到的除类之外的所有数据类型都属于值类型。只有类是引用类型。 值类型和引用类型最大的区别是当进行数据传输时，值类型总是被复制。而引用类型不会被复制。 结构体vs类：结构体开发者并不需要提供构造方法，结构体会根据属性自动生成一个构造方法。而类则要求开发者自己提供构造方法。 Swift语言中Array，String，Dict都是通过结构体实现的。 Swift属性分存储属性和计算属性。存储属性用于描述存储值；计算属性：用于描述计算过程并获取计算结果 Swift属性还支持延迟存储属性。只有当开发者调用到类实例的这个属性才完成构造。","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"React Native热更新一些命令","date":"2017-11-01T15:16:26.000Z","path":"2017/11/02/React-Native热更新杂记/","text":"CodePush巨硬提供的一套热更新策略。使用CodePush 可以进行实时的推送代码更新。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。 CodePush开源了react-native版本，react-native-code-push托管在GitHub上。 在公司开发的APP上，上周集成了热更新。碰到了一些小bug，热更新搞一哈，悄悄地把问题改掉咯。免去了发版的烦恼。（仅限于JS bundle部分，要是修改了原生，使用了link操作。还是得老老实实发版） CodePush的一些命令账户相关12345678910code-push app add 在账号里面添加一个新的appcode-push app remove 或者 rm 在账号里移除一个appcode-push app rename 重命名一个存在appcode-push app list 或则 ls 列出账号下面的所有appcode-push app transfer 把app的所有权转移到另外一个账号code-push login 登陆code-push loout 注销code-push access-key ls 列出登陆的tokencode-push access-key rm &lt;accessKye&gt; 删除某个 access-keycode-push app list 或则 ls 列出账号下面的所有app 打包发布1code-push release-react &lt;appName&gt; &lt;platform&gt; -t 版本 -d 环境 --des 描述 eg： 12code-push release-react App-iOS ios -t 2.10.0 -d Production --des &#x27;一段描述&#x27;//其中参数–t为二进制(.ipa与apk)安装包的的版本；–dev为是否启用开发者模式(默认为false)；–d是要发布更新的环境分Production与Staging(默认为Staging)；–des为更新说明；–m 是强制更新。 注意：热更新的版本必须和app版本相同才有效。高或者低都无效。 部署12345678// 清除历史部署记录code-push deployment clear &lt;appName&gt; Production or Staging// 列出应用的部署情况code-push deployment ls &lt;appName&gt;// 查看部署的keycode-push deployment ls &lt;appName&gt; -k // 部署记录历史code-push deployment history uniApp-IOS Production or Staging","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"React Native开发遇到的一些坑","date":"2017-10-24T16:03:34.000Z","path":"2017/10/25/React Native开发遇到的一些坑/","text":"距上篇博文有间隔了好一阵。10月初，用RN写的app上架以后，马不停蹄地有整出来一份同业的版本，之后就全力进行二期的优化。其实就是填坑。每天忙忙碌碌，烦心事闹心事也不少。不过看到自己完成的app上store，同事夸app好用，心里还是美滋滋的。回首搞app开发这几个月，真是成长了不少。 言归正传，在这总结一下RN开发中的一些坑： react-navigationreact-navigation作为官方推荐的导航跳转的工具，比起之前的navigator好用不少。当然也有不少问题。 goBack（）问题 react-navigation提供有goBack()这api, 但是使用返回栈中某个组件的方法this.props.navigation.goBack(‘component’)或this.props.navigation.dispatch(NavigationActions.back({key: “component”}))没有反应, 原理是因为这里的component不是用自定义的routeName而是用自动生成的随机值key. 又没有提供有api获取组件的key, 手动去获取又十分麻烦。这里我们可以修改他的源码：把项目&#x2F;node_modules&#x2F;react-navigation&#x2F;src&#x2F;routers&#x2F;StackRouter.js中 1const backRoute = state.routes.find((route: *) =&gt; route.key === action.key); 改为： 1const backRoute = state.routes.find(route =&gt; route.routeName === action.key); 这样的话，里的component要填想返回的组件的前一个组件的routeName, 比如你的栈里顺序是home1, home2, home3, home4, 在home4里要返回home2, 使用this.props.navigation.goBack(‘home3’);; 并且又会带出一个问题: goBack()方法没反应了, 必须加个null进去, 写成goBack(null) 快速点击多次跳转问题 当我们快速点击x按钮，请求跳转时。如果快速地点击两下，三下。会导致快速跳转。这里的解决方案是加入一个setTimeout函数。 修改react-navigation目录下，scr文件夹中的addNavigationHelpers.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export default function&lt;S: *&gt;(navigation: NavigationProp&lt;S, NavigationAction&gt;) &#123; // 添加点击判断 let debounce = true; return &#123; ...navigation, goBack: (key?: ?string): boolean =&gt; navigation.dispatch( NavigationActions.back(&#123; key: key === undefined ? navigation.state.key : key, &#125;), ), navigate: (routeName: string, params?: NavigationParams, action?: NavigationAction,): boolean =&gt; &#123; if (debounce) &#123; debounce = false; navigation.dispatch( NavigationActions.navigate(&#123; routeName, params, action, &#125;), ); setTimeout( () =&gt; &#123; debounce = true; &#125;, 500, ); return true; &#125; return false; &#125;, /** * For updating current route params. For example the nav bar title and * buttons are based on the route params. * This means `setParams` can be used to update nav bar for example. */ setParams: (params: NavigationParams): boolean =&gt; navigation.dispatch( NavigationActions.setParams(&#123; params, key: navigation.state.key, &#125;), ), &#125;;&#125; 底部多个TextInput，输入法遮盖问题安卓上貌似不会出现这个问题，主要是ios端。一开始使用的是原生的IQKeyBoardManager。但是多个TextInput情况下。支持的不是太好。这里使用了一块开源的组件：react-native-keyboard-aware-scroll-view 完美解决这个问题。 react-native-lightbox这个组件实现了点击图片，灯箱效果。不过它的问题蛮多的。遇到的第一个问题就是Pinch to zoom。这个组件本身不支持灯箱效果下，手势放大。这里使用了一个小技巧。通过本身的swipeToDismiss&#x3D;{false}以及ScrollView的minimumZoomScale和maximumZoomScale属性解决这个问题。 eg: 1234567891011121314151617&lt;LightBox key=&#123;i&#125; swipeToDismiss=&#123;false&#125; &gt; &lt;ScrollView minimumZoomScale=&#123;1&#125; maximumZoomScale=&#123;2&#125; centerContent=&#123;true&#125; &gt; &lt;Image style=&#123;styles.image&#125; source=&#123;&#123;&#x27;uri&#x27; : source&#125;&#125; &gt; &lt;/Image&gt; &lt;/ScrollView&gt; &lt;/LightBox&gt; 这个组件还有一个坑是，点击图片出现灯箱效果之后。IOS端的顶部StatusBar信息莫名其妙的消失了。排查了一大圈，发现是这个组件自己写没了。这里需要修改一下源码 &#x2F;node_modules&#x2F;react-native-lightbox&#x2F;LightboxOverlay.js:135 line: 1StatusBar.setHidden(true, &#x27;fade&#x27;); -&gt; StatusBar.setHidden(false, &#x27;fade&#x27;); scrollview的触摸滚动事件在这里详细的列举一下： 1234567891011121314151617181920212223242526271、onScrollBeginDrag：一个子view滑动开始拖动开始时触发，注意和onMomentumScrollBegin的区别2、onScrollEndDrag：一个子view滚动结束拖拽时触发，注意和onMomentumScrollEnd的区别3、onTouchStart：按下屏幕时触发4、onTouchMove：移动手指时触发5、onTouchEnd：手指离开屏幕触摸结束时触发6、onMomentumScrollBegin：当一帧滚动开始时调用.7、onMomentumScrollEnd：当一帧滚动完毕时调用.8、onStartShouldSetResponder：触摸开始时是否成为响应者9、onStartShouldSetResponderCapture：防止子视图在触摸开始时成为应答器10、onScrollShouldSetResponder：滚动时是否成为响应者11、onResponderGrant：开始响应时触发12、onResponderRelease：手指释放后，视图成为响应者13、onResponderReject：另一个响应已经被激活, 响应者不会释放它到该视图14、onScroll：滚动时触发，会触发多次 下面是在网上找到的两张图，分别是ios端的测试和Android端的： WebView自适应高度在做APP的时候遇到了一个需求就是希望页面中的文字可以复制。如果是Text组件下的。这个好说一个selectable&#x3D;{true}属性搞定。但是selectable&#x3D;{true}这个属性。在ios端只支持整段话的复制。不支持，选哪儿复制那这种操作。之前查了一下好像是和底层OC代码有关。Android这块没有问题。为了实现需求，采用了Webview的方式。（从接口的到的字段也是超文本类型的）。但是这里出现了一个问题就是WebView无法根据提供内容的多少自适应高度。 ReactNative中的WebView需要设定高度才能展示出来，因此需要用js来计算文档高度做到高度自适应。一个思路就是让WebView和React的JS进行通信。页面加载后，webview内的JS代码获取自己的高度，添加一个hash给自己的URL，React当感知到webview加载状态变化后，读取这个hash值，传递给this.state.WebViewHeight，从而改变WebView的高度。 第二种思路就是万能的github。试了好几个组件之后，一个国人开发的react-native-autoheight-webview最好用。 不过有一个诡异的现象是value值很少的情况下无法进行长按选中字段复制。字数多的时候 （4，5行以上）功能正常。这个问题的解决： 123// default width is the width of screen// to fix that it can not select text when the length of it is not long enough on iOS, the width should be reduced more than 15style=&#123;&#123; width: Dimensions.get(&#x27;window&#x27;).width - 15 &#125;&#125; react-native-scrollable-tab-view这个组件是tab切换用的。其实react-navigation也有这个功能。它有一个问题是。在多个页面切换下无法正确的显示页面的高。默认选用的是最长的那个。（Tab view always has the height equal to height of the highest tab） 在issue上看到不少人碰到这个问题。一个不是很完美的解决方案就是： Use ScrollView as tabs. eg： 123456789&lt;ScrollableTabView style=&#123;&#123; height: Dimensions.get(&#x27;window&#x27;).height &#125;&#125;&gt; &lt;ScrollView&gt; &lt;View style=&#123;&#123; height: 300, backgroundColor: &#x27;cadetblue&#x27; &#125;&#125; /&gt; &lt;/ScrollView&gt; &lt;SrcollView&gt; &lt;View style=&#123;&#123; height: 5000, backgroundColor: &#x27;lightgreen&#x27; &#125;&#125; /&gt; &lt;/ScrollView&gt;&lt;/ScrollableTabView&gt; MAC对APK包进行重新签名jarsigner -verbose -keystore [您的私钥存放路径] -signedjar [签名后文件存放路径] [未签名的文件路径] [您的证书名称] 12345jarsigner的参数说明-keystore 参数指定您的私钥的绝对路径,例如：/Users/haoweilai/mykeystore-signedjar 参数指定签名后apk文件存放绝对的路径,例如 /Users/haoweilai/signed.apk[未签名的文件路径] 指定要签名apk文件的绝对路径,也就是您从我们这里下载到的，例如 /Users/haoweilai/meizuemptyapk-release-unsigned.apk[您的证书名称] 是指您创建密钥时您设置的证书名称 以上 先总结这些，想到了再补充。RN还有太多太多知识需要掌握。原生，redux，优化。加油~","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"CSS预处理工具--Stylus（2）","date":"2017-10-06T06:18:32.000Z","path":"2017/10/06/CSS预处理工具--Stylus（2）/","text":"内建函数： 颜色函数： darken&#x2F;lighten 123456789.btn-primary background-color $primary-color border-color darken($primary-color, 15%).link color red &amp;:hover color lighten(red, 10%) 嵌入图片：embedurl 12345background: embedurl(&#x27;logo.png&#x27;)// =&gt; background: url(&quot;data:image/png;base64,…&quot;)background: embedurl(&#x27;logo.svg&#x27;, &#x27;utf8&#x27;)// =&gt; background: url(&quot;data:image/svg+xml;charset=utf-8,…&quot;) 添加前缀：+prefix-classes(prefix) 123456+prefix-classes(&#x27;.tqb-dp-&#x27;) .header height 2.5rem .back-button color white 编译为： 123456.tqb-dp-header &#123; height: 2.5rem;&#125;.tqb-dp-header .tqb-dp-back-button &#123; color: white;&#125; 生态： NIB Nib 是 Stylus 样式库，用于将样式进行兼容性处理类似 Compass position: 12#back-to-top fixed bottom right 编译为： 12345#back-to-top &#123; position: fixed; right: 0; bottom: 0;&#125; 渐变色： 1234@import &#x27;nib&#x27;body background linear-gradient(top, white, black) 编译为： 123456body &#123; background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #fff), color-stop(1, #000)); background: -webkit-linear-gradient(top, #fff 0%, #000 100%); background: -moz-linear-gradient(top, #fff 0%, #000 100%); background: linear-gradient(top, #fff 0%, #000 100%);&#125; CSS小技巧~固定比例的容器： 123456789.intrinsic-ratio-box height 0 padding-bottom 20% position relative .real-container absolute top left width 100% height 100% 视觉上不可见: 屏幕上不可见，但对搜索引擎和阅读器可见。 12345678910.visually-hidden border 0 clip rect(0,0,0,0) position absolute width 1px height 1px margin -1px overflow hidden padding 0``","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Stylus","slug":"Stylus","permalink":"http://yoursite.com/tags/Stylus/"}]},{"title":"CSS预处理工具--Stylus","date":"2017-10-05T16:18:44.000Z","path":"2017/10/06/CSS预处理工具--Stylus/","text":"（2017.10.4 兰州·黄河） 为什么是Stylus？Stylus vs Sass ：Sass 在win下中文字符兼容不是太好。出现的比较早，相比之下少一些新晋的功能 Stylus vs PostCSS：势均力敌，速度都很快，支持自己写扩展。都是用node开发。 stylus优势：1，语法上，无限接近JS。2，极尽简化，又向上兼容。3，强力的@extend （不仅可以继承类还有继承选择器）。4，不需要复杂的配置。 安装：npm install stylus -g 编译css：stylus [options][文件|目录…] -o css&#x2F;eg: stylus .\\index.stylus -o css 常用option： -i 启动一个交互工具 （有很多有用的小函数） 1234&gt; darken(#fff, 10%)=&gt; #e6e6e6&gt; rgb(201,163,59)=&gt; #c9a33b -U 把图片转化为Data URI -w 监视文件状态，自动编译 -c 压缩输出的css -m 生成SourceMap –include-css 输出文件中包含@import导入的CSS http://stylus-lang.com/try.html(官方游乐场&#x3D; &#x3D;) 日常：package.json: 12345&#123; &quot;scripts&quot;: &#123; &quot;stylus&quot;: &quot;mkdir css &amp; stylus -m -w styl/screen.styl -o css/&quot; &#125;&#125; GULP: 1npm i gulp-stylus gulp-clean-css -D gulpfile.js 123456789101112gulp.task(&#x27;stylus&#x27;, () =&gt; &#123; return gulp.src(&#x27;./styl/screen.styl&#x27;) .pipe(stylus(&#123; compress: true, &#x27;include css&#x27;: true &#125;)) .pipe(cleanCSS(&#123; level: 2, rebaseTo: &#x27;css/&#x27; &#125;)) .pipe(gulp.dest(DEST + &#x27;css/&#x27;));&#125;); 一些内部功能： 选择器^[N..M] 12345678a b c d font-size 14px .abc ^[-1..-1]:hover color red 编译为： 123456a b c d &#123; font-size: 14px;&#125;.abc d:hover &#123; color: #f00;&#125; 引用属性值 123p margin 10px padding (@margin / 2) 编译为： 1234p &#123; margin: 10px; padding: 5px;&#125; eg: 12345678910// 用绝对定位居中#logo position absolute top 50% left 50% width 150px height 80px margin-left -(@width / 2) margin-top -(@height / 2) margin (-@height / 2) 0 0 (-@width / 2) 循环 123for n in 1..10.col-&#123;n&#125; width 10% * n 编译为： 1234567 .col-1 &#123; width: 10%;&#125;.col-2 &#123; width: 20%;&#125;.... 条件判断 IF&#x2F;ELSE 1234567$need-support-ie = truebody if $need-support-ie padding 5px else margin 5px (直接修改开关) MIXIN &amp; FUNCTIONS(全部参数 ARGS…) 12345678910111213141516border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius nform input[type=button] border-radius(5px) // function border-radius 5px // mixin box-shadow(args...) -webkit-box-shadow args -moz-box-shadow args box-shadow args a box-shadow 1px 2px 5px #eee 编译为: 12345678910form input[type=button] &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125;a &#123; -webkit-box-shadow: 1px 2px 5px #eee; -moz-box-shadow: 1px 2px 5px #eee; box-shadow: 1px 2px 5px #eee;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Stylus","slug":"Stylus","permalink":"http://yoursite.com/tags/Stylus/"}]},{"title":"React-Native IOS及安卓打包","date":"2017-09-29T15:35:26.000Z","path":"2017/09/30/React-Native IOS及安卓打包/","text":"开发了快两个月的RN终于到了要打包发布的阶段。 网上有不少文章博客，还是RN更新太快的缘由，有些并不适用于当前版本。这里简单说一下吧。（这里用的是RN0.43.4） IOS首先在项目根目录创建一个空文件夹，我这里创建的是：release_ios 之后执行打包命令（有点像webpack将JS代码压缩合并，并且导出所使用的静态资源） 1react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ 命令具体含义： –entry-file ,ios或者android入口的js名称，比如index.ios.js –platform ,平台名称(ios或者android) –dev ,设置为false的时候将会对JavaScript代码进行优化处理。 –bundle-output, 生成的jsbundle文件的名称，比如 release_ios&#x2F;main.jsbundle –assets-dest 图片以及其他资源存放的目录,比如 release_ios&#x2F; 大概1，2min打包ok。在我们的新建文件夹中就会有相应的bundle文件。 在之后打开xCode。将bundle文件拖拽到项目中。（++点击options，一定要勾选Create folder references选项，将bundle文件夹添加到项目里，Xcode下该文件夹一定要是蓝色的。++）修改AppDelegate.m中的代码,替换jsCodeLocation ，注释掉之前的jsCodeLocation 代码。 12//jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil];+jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;]; 最后将项目由debug状态改成release状态，Xcode–&gt;Product–&gt;Scheme–&gt;Edit Scheme…（在此期间选择 Generic iOS Device ,修改Version和Build号） 最后command+shift+k clean一下项目。选择Archice。就可以生成ipa包咯。 Androidandroid这块打包很简单。这里主要说一下真机调试。走了不少弯路。（比ios方便很多。）首先，在项目根目录下启动服务： 1react-native start 手机打开开发者中的USB调试，链接上PC。通过命令： 1adb reverse tcp:8081 tcp:8081 将手机与rn的node服务链接。 最后在android studio中编译运行选择连接上的设备就ok咯。 安卓这块开发还是建议使用真机链接的方式。ios端模拟器相对流畅，安卓模拟器（这里mac pro13）卡的不要不要的。很影响开发效率。 打包的话 直接看官方文档就ok 以上","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"React Native 配置自定义字体","date":"2017-09-24T06:07:52.000Z","path":"2017/09/24/React-Native-配置自定义字体/","text":"本想着配置自定义字体不是什么大坑，官网文档找了一下，没有。遂关键字：“React Native 配置自定义字体”这么一搜。都是一样的文章，作者名却是各式各样，真是天下文章大家抄。然而试了一下并不好用。 （这里使用最新的RN 0.48.4 测试） 这里想一下React Native最新的，最省事的配置自定自定义字体的方法：1）随便下载一个字体（不要改名字，会有坑）我这里随便下了一个scratchmyback的英文字体。 SCRATCHMYBACK.TTF 2）在项目根目录创建文件夹assets&#x2F;fonts。并把刚才下载的字体放进去。 3）在Package.json告诉React Native 咱们自定义的字体在哪里： 12345&quot;rnpm&quot;: &#123; &quot;assets&quot;: [ &quot;./assets/fonts/&quot; ]&#125; react-native link （并不需要手动打开xcode，copy文件夹进项目） IOS需要在Info.plist文件里添加将要使用的自定义字体： 1234&lt;key&gt;UIAppFonts&lt;/key&gt;&lt;array&gt; &lt;string&gt;SCRATCHMYBACK.TTF&lt;/string&gt;&lt;/array&gt; Android link操作自动把引入字体copy到了android&#x2F;app&#x2F;src&#x2F;main&#x2F;assets&#x2F;fonts&#x2F;文件夹下。确认一下就好。 6）现在就可以在香炉里通过fontFamily使用自定义字体咯。重新编译一下 大功告成~","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"React-Native用到的第三方组件","date":"2017-09-17T15:14:44.000Z","path":"2017/09/18/React-Native用到的第三方组件/","text":"这一个多月一直在搞公司的App项目，采用的技术就是React Native。一个人蒙着眼摸着石头过河，第一版总算是接近尾声了。（其实还有好多好多坑···）在这里总结一下，开发中用到的第三方组件。 （2016·秋–湘南） 说道第三方组件，React Native的社区非常非常的活跃。各式各样的开源组件。开发时需要什么功能，google一下，绝大多数情况都能找到符合需求的组件。不过，RN有个大坑就是更新太快了。一个月前还是0.45吧，现在已经0.48了。而且改动非常巨大，带来的问题就是有些组件这个版本ok，，下个版本GG。也有这个版本ok，作者无暇适配开发老版本的兼容。当然还有很多第三方组件自身有Bug，提供的接口太少，样式太死板。Link Ios&#x2F;Android的时候由于版本引起的神秘报错。总之。寻找一款合适的第三方组件，真的是需要耐心的。 这次App开发采用的是0.43.4这个版本。（0.44这个版本改动非常巨大。立项目之初，保守一点选择了这个版本）。 1.react-native-animatable：动画。RN一个痛点就是动画，这个组件按照Animated.css提供的特效进行RN化。 2.react-native-camera+react-native-qrcode-scanner：两者配合解决了扫一扫功能。这里值得注意的是，qrcode-scanner基于.react-native-camera0.10.0实现的。而0.10.0只支持RN0.40以上的版本。https://github.com/moaazsidat/react-native-qrcode-scanner（这个star不是很多，不过真的很好用） 3.react-native-dash：画虚线 4.react-native-device-info：获取真机信息。机子类型&#x2F;系统版本都能获取出来。（反馈功能，提供所使用的真机信息） 5.leancloud-storage：LeanCloud。国内的BaaS提供商。也是为了反馈这个功能而使用的，意外的好用。将数据存储这块交给了它。 6.react-native-easy-toast：原生的Toast提示 7.react-native-fetch-blob：下载这块用的这个，非常强大。下载api地址的json内容。json里的网络图片url，一并拉下来，缓存在本地进行处理都依赖于这个组件。 8.react-native-img-cache：依赖于react-native-fetch-blob的图片缓存组件。基本就上上述组件的一个封装。更加简单易用一些。不需要一口气下载下来的图片，都使用了这个组件。 9.react-native-autoheight-webview：WebView高度自适应组件。基于Webview组件这个方法onNavigationStateChange（）的一个封装调用。原理就是：webview内的JS代码获取自己的高度，添加一个hash给自己的URL，React当感知到webview加载状态变化后，读取这个hash值，传递给this.state.WebViewHeight，从而改变WebView的高度。 10.react-native-image-pan-zoom：图片手势放大缩小 11.react-native-linear-gradient：渐变效果。RN本身样式里不支持渐变。这里引用它，搞定！ 12.react-native-modalbox：模态视图。其实github上modal这块功能相同的组件蛮多的。star最前的三四个都试了一下。这个最好用。 13.react-native-pdf： 支持url PDF的下载查看。star最多的那个react-native-pdf-view只支持本地pdf的查看。这个组件找了好久(https://github.com/wonday/react-native-pdf) 14.react-native-maps: airbnb开源的map。ios用的native apple map。Android这块用的 google map。功能非常强大。这个组件配置安装比较复杂。还有一个大坑就是国内安卓没有google play。由于所做的app 地图模块对应的海外。现在的解决方案很傻。ios用native map。Android跳转google map。如果开发的app仅仅需要国内map部分这里推荐：react-native-amap3d。国人开发的高德地图组件安卓部分用的Kotlin。亲测好用。功能很强大：手势交互、标记、绘图·热力图、海点图、导航都ok 15.react-native-spinkit: 一些现成的等待状态的会动图标。app里下载这个状态就用的这个。 16.react-native-vector-icons： 大而全的字体图标库。 17.react-native-snap-carousel： 轮播图组件。有别于react-native-swiper的是：他有点像kindle APP里显示图书那一块的轮播。有缩放显示。 就这些吧。还有一些大众的比如react-native-tab-navigator、react-navigation、react-native-scrollable-tab-view就不在赘言咯。 有时间在把开发中的一些坑总结总结~","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"杂","date":"2017-08-19T09:42:58.000Z","path":"2017/08/19/杂/","text":"不知不觉在新的公司，工作了快四个月了。从一个标准的Java后端转到前端。跨度还是蛮大的。对于后端来说，特别是相对成熟的Java，SSH这三大框架搞明白，操纵操纵数据库。完成业务需求就是了。前端则不一样，要去和设计&#x2F;后端沟通，还要跟上新技术的浪潮。 说道技术浪潮，从学习前端开始真的是感受到了互联网技术上的发展之快。从传统的Dom层框架JQ&#x2F;Yui到现在，MVVM框架的盛行。ES5，ES6，再到现在的ES7。稍微放慢一些脚步就有种跟不上的感觉。和日本的安逸生活相比繁忙了很多，压力也大了。倒是回过头想想确实成长了不少。现在一个人在搞公司App，用的RN。坑很多，不过每一个小功能的实现，带来的成就感，也让自己很满足。 工作方面，公司很年轻。基本都是90后吧，也都很强。不像在日本，办公室里一堆敲代码的老头子。年轻当然有好有坏，自由算是最大的优点。基本自己想怎么搞就怎么搞。说实话在日本习惯条条框框的自己来说，直到现在还不是太习惯。自由崇尚敏捷开发：带来的就是没有测试，没有标准的代码风格。看起来代码比较混乱。日本正好相反，一层一层的review。很多的规矩。简直是两个极端&#x3D;。&#x3D; 这几个月，不想把日语放下，7月初又考了一次N1。其实成绩对自己来说没什么意义，只是当作一种学习的督促吧。上上周回了趟西安。奶奶病重，一种说不出来的感觉。看着苍老很多的父亲，心里很不是滋味。这些年，自己的任性，倔强，让父母操了不少心。25了再任性前再考虑考虑吧。是无奈也是责任。 最近北京阴雨绵绵，很像日本的梅雨天。空气潮潮的，一点都不北京。 夏天就这么过去了~","tags":[{"name":"杂","slug":"杂","permalink":"http://yoursite.com/tags/%E6%9D%82/"}]},{"title":"JavaScript Standard Style","date":"2017-08-02T15:14:58.000Z","path":"2017/08/03/JavaScriptStandardStyle/","text":"最近公司新开的RN项目，使用了这份JS编码规范。在这里简单的介绍一下。 https://github.com/standard/standard（star超级多&#x3D;。&#x3D;） 相比Eslint、JSCS这类代码检查工作，优势就是，自有一套社区规范化的[标准]风格。不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。自动代码格式化。在主流的编译器上sublime&#x2F;vscode&#x2F;Atom&#x2F;Vim都有相应的插件提供支持。实际体验很好。 再来说说这一套JS编码规范的细则： 2 spaces – for indentation Single quotes for strings – except to avoid escaping No unused variables – this one catches tons of bugs! No semicolons – It’s fine. Really! Never start a line with (, [, or &#96; This is the only gotcha with omitting semicolons – automatically checked for you! Space after keywords if (condition) { … } Space after function name function name (arg) { … } Always use &#x3D;&#x3D;&#x3D; instead of &#x3D;&#x3D; – but obj &#x3D;&#x3D; null is allowed to check null || undefined. Always handle the node.js err function parameter Always prefix browser globals with window – except document and navigator are okay Prevents accidental use of poorly-named browser globals like open, length, event, and name. And more goodness – give standard a try today! 仔细看这一串规范，大概最大的争议点是：没有分号。 Standard Style的作者Feross（google了一下，很NB的一个人）他自己认为不用分号的 JavaScript 非常好。分号自动插入是 JavaScript 的一个特性，它可以减少噪点、简化程序。 看了这么长也许你会想，如果我不同意某条规则，可以改吗？ 答案是不行的，Feross认为制定这套 standard 规范的目的就是让大家都不必再花时间浪费在无谓的代码风格之争上面了。遵循 standard 规范，你就不用再犹豫了，毕竟不管怎样争论总归会选择一种风格的。 好一阵子没写blog了，不知不觉在新公司有一阵子时间了。相比日本企业，国内的公司更自由，但压力也多了许多。从日本回来之前，这些都想到了。一点不后悔。在日本清闲了几年，回国了还是要好好努力把空缺补一补。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"},{"name":"standard","slug":"standard","permalink":"http://yoursite.com/tags/standard/"}]},{"title":"React Native学习--布局问题","date":"2017-06-10T08:49:20.000Z","path":"2017/06/10/React-Native学习--布局问题/","text":"最近一直闲暇时间一直在看RN。大概之前主要看Vue，对React只是了解的缘故。直接上RN，扑面而来一箩筐的概念和知识（不光是React还有ios&#x2F;Android ，没有原生开发经验，上周在配置1环境的时候就踩了不少坑&#x3D;。&#x3D;）。 今儿主要说说RN中的布局问题。RN采用的布局方式是FlexBox。现代浏览器还是会有FlexBox的兼容问题，在网页开发多少会有一些限制。而RN，是面向ios&#x2F;Android的。既然RN对FlexBox支持。我们大可不必关心兼容性问题。 RN的单位首先要说的是RN中的尺寸。在RN中尺寸是没有单位的，他代表设备独立像素。eg： 123&lt;View style=&#123; &#123;width:100,height:100,margin:40,backgroundColor:&#x27;gray&#x27;&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,margin:20&#125;&#125;&gt;尺寸&lt;/Text&gt;&lt;/View&gt; 这里使用无单位的尺寸，是为了确保布局在任何不同的dpi的手机屏幕上不会发生改变。在上面的代码中： 运行在Android上时，View的长和宽被解释成：100dp 100dp单位是dp，字体被解释成16sp 单位是sp，运行在iOS上时尺寸单位被解释称了pt。 RN&#x2F;web css上FlexBox的不同之处lexDirection: React Native中默认为flexDirection:&#39;column&#39;，在Web CSS中默认为flex-direction:&#39;row&#39; alignItems: React Native中默认为alignItems:&#39;stretch&#39;，在Web CSS中默认align-items:&#39;flex-start&#39; flex: 相比Web CSS的flex接受多参数，如:flex: 2 2 10%;，但在 React Native中flex只接受一个参数 不支持属性：align-content，flex-basis，order，flex-basis，flex-flow，flex-grow，flex-shrink 以上是React Native中的FlexBox 和Web CSSS上FlexBox的不同之处。 Flex in React Native容器属性： flexDirection enum(‘row’, ‘column’,’row-reverse’,’column-reverse’) flexWrap enum(‘wrap’, ‘nowrap’)（nowrap flex的元素只排列在一行上，可能导致溢出。&#x2F;wrap flex的元素在一行排列不下时，就进行多行排列。） justifyContent enum(‘flex-start’, ‘flex-end’, ‘center’, ‘space-between’, ‘space-around’) alignItems enum(‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’) 子容器属性： alignSelf enum(‘auto’, ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’)alignSelf 属性可重写灵活容器的 alignItems 属性。 flex number(属性定义了一个可伸缩元素的能力，默认为0) 其他布局 in RN视图边框： borderBottomWidth number 底部边框宽度 borderLeftWidth number 左边框宽度 borderRightWidth number 右边框宽度 borderTopWidth number 顶部边框宽度 borderWidth number 边框宽度 borderColor 边框颜色 尺寸： width number height numb margin： margin number 外边距 marginBottom number 下外边距 marginHorizontal number 左右外边距 marginLeft number 左外边距 marginRight number 右外边距 marginTop number 上外边距 marginVertical number 上下外边距 padding： padding number 内边距 paddingBottom number 下内边距 paddingHorizontal number 左右内边距 paddingLeft number 做内边距 paddingRight number 右内边距 paddingTop number 上内边距 paddingVertical number 上下内边距 定位： position enum(‘absolute’, ‘relative’)属性设置元素的定位方式，为将要定位的元素定义定位规则。 参考：A Complete Guide to Flexbox Using CSS flexible boxes","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"react-native学习笔记","date":"2017-06-04T15:28:48.000Z","path":"2017/06/05/react-native学习笔记(1)/","text":"周末两天的RN初体验，一些杂乱的笔记。 传统开发：人员稀缺；开发成本高；代码复用；无法实现动态更新 优点：learn once,write anywhere跨平台 性能高 低投入高回报 支持动态更新 first app command+d 在模拟器里打开 开发者菜单 react-native run-ios （没什么坑直接用就好，启动xcode里的ios模拟器） Android这边坑比较多遇到的第一个问题： Unable to access Android SDK add-on list解决方案： 在 Android Studio 安装目录 bin&#x2F;idea.properties 文件最后追加一句 disable.android.first.run=true Android Studio SDK配置问题： http://reactnative.cn/docs/0.44/getting-started.html 这一块不管是中文doc还是英文都没更新。最新版本的RN 不支持SDK25以下的了。都用最新的就好。要注意的是Show Package Details里面的选项。（这块坑了好久- -） 之后运行项目遇到这个错误 Error calling Appregistry.runApplication 全局变量配置： open .bash_profile 粘贴如下代码： 12export ANDROID_HOME=~/Library/Android/sdkexport PATH=$&#123;PATH&#125;:/Users/lac/Library/Android/sdk/tools:/Users/lac/Library/Android/sdk/platform-tools source .bash_profile 配置好全局变量 这下就可以运行adb了； adb reverse tcp:8081 tcp:8081 run react-native start in the background then run react-native run-android. 命令行启动Android模拟器： ~&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;tools&#x2F;emulator -avd a25 三种定义组件的方法 es6定义组件： 12345 export default class HelloComponent extends Component&#123; render() &#123; return &lt;Text style=&#123;&#123;fontSize:20,backgroundColor:&#x27;red&#x27;&#125;&#125;&gt;Hello&lt;/Text&gt; &#125;&#125; es5定义组件： 123456var HelloComponent=React.createClass(&#123; render() &#123; return &lt;Text style=&#123;&#123;fontSize:20,backgroundColor:&#x27;red&#x27;&#125;&#125;&gt;Hello&lt;/Text&gt; &#125; &#125;)module.exports=HelloComponent; 函数式创建组件(无状态的（不能使用this）)： 1234function HelloComponent() &#123; return &lt;Text style=&#123;&#123;fontSize:20,backgroundColor:&#x27;red&#x27;&#125;&#125;&gt;Hello&lt;/Text&gt;;&#125;module.exports=HelloComponent; console.log页面：http://localhost:8081/debugger-ui 如何导出一个组件？如何使用导出的组件？ ES6 通过export default导出组件，通过import使用组件ES5通过module.exports&#x3D;组件名字 如何导出一个变量或常量？如何使用导出的变量和常量？导出： var name=&quot;Lac&quot;; const age = &quot;18&quot;; export &#123;name,age&#125;; 导入 在import里使用{name,age} 如何导出一个方法？如何使用导出的方法？ export function sum(a,b) &#123; return a+b; &#125; 导入 在import里使用{sum} 设置默认属性(在组件没有传递props时候)1234567static defaultProps = &#123; name:&#x27;Bill&#x27; &#125; // 属性检查机制 （要import &#123;PropsTest&#125; static propTypes = &#123; name:PropTypes.String, &#125; *props是只读的，不可改变 Es6 延展操作符： 之前：向一个组件中传递属性： var params = &#123; name:&#39;小张&#39;, age:24 &#125; &lt;PropsTest name=&#123;params.name&#125; age=&#123;params.age&#125; /&gt; Es6中可以这样：(在传递很多属性是非常方便) &lt;PropsTest &#123;...parmas&#125; /&gt; 结构赋值（获取指定的属性（es6）） var &#123;name&#125;=parmas; &lt;PropsTest name=&#123;name&#125; /&gt; ​ref:组件被渲染后指向组件的一个引用 todo···","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"Git命令复习笔记","date":"2017-05-10T16:08:42.000Z","path":"2017/05/11/git命令复习笔记/","text":"初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 每次修改，如果不add到暂存区，那就不会加入到commit中。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 要关联一个远程库，使用命令git remote add origin git@server-name:path&#x2F;repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 概览：master合并merge解决好的bug后，不要先把dev解印，先合并master，获取里面的bug方案后，在解印。解印时会有提示冲突，需手动改一次文件。 1：在 dev 下正常开发中，说有1个bug要解决，首先我需要把dev分支封存stash 2：在master下新建一个issue-101分支，解决bug，成功后 3：在master下合并issue-101 4：在 dev 下合并master， 这样才同步了里面的bug解决方案 5：解开dev封印stash pop，系统自动合并 &amp; 提示有冲突，因为封存前dev写了东西，此时去文件里手动改冲突 6：继续开发dev，最后add，commit 7：在master下合并最后完成的dev 代码过程如下： 1234567891011121314151617181920212223242526272829在此插入代码1： $ git stash2： $ git checkout master $ git checkout -b issue-101 //去文件里修bug $ git add README.md $ git commit -m &quot;fix-issue-101&quot;3： $ git checkout master $ git merge --no-ff -m &quot;m-merge-issue-101&quot; issue-101 $ git branch -d issue-1014： $ git checkout dev $ git merge --no-ff -m &quot;dev-merge-m&quot; master5： $ git stash pop //提示冲突，去文件手动改正 Auto-merging README.md CONFLICT (content): Merge conflict in README.md6： //继续开发 ... ... ，完成后一并提交 $ git add README.md $ git commit -m &quot;fixconflict &amp; append something&quot;7： $ git checkout master $ git merge --no-ff -m &quot;m-merge-dev&quot; dev $ git branch -d dev 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin&#x2F;branch-name。 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 TAG命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…”可以指定标签信息； git tag -s -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签。 （05.11追加） 撤销一个公共修改 Undo a “public” change场景：你刚刚用git push将本地修改推送到了GitHub，这时你意识到在提交中有一个错误。你想撤销这次提交。 使用撤销命令：git revert 发生了什么：git revert将根据给定SHA的相反值，创建一个新的提交。如果旧提交是“matter”，那么新的提交就是“anti-matter”——旧提交中所有已移除的东西将会被添加进到新提交中，旧提交中增加的东西将在新提交中移除。 这是Git最安全、也是最简单的“撤销”场景，因为这样不会修改历史记录——你现在可以git push下刚刚revert之后的提交来纠正错误了。 撤销本地更改 Undo “local” changes场景：你正在编辑的文件被保存了但是你的编辑器恰在此时崩溃了。此时你并没有提交过代码。你期望撤销这个文件中的所有修改——将这个文件回退到上次提交的状态。 使用撤销命令：git checkout — 发生了什么：git checkout将工作目录（working directory）里的文件修改成先前Git已知的状态。你可以提供一个期待回退分支的名字或者一个确切的SHA码，Git也会默认检出HEAD——即：当前分支的上一次提交。 注意：用这种方法“撤销”的修改都将真正的消失。它们永远不会被提交。因此Git不能恢复它们。此时，一定要明确自己在做什么！（或许可以用git diff来确定） 重置本地修改 Reset “local” changes 场景：你已经在本地做了一些提交（还没push），但所有的东西都糟糕透了，你想撤销最近的三次提交——就像它们从没发生过一样。 使用撤销命令：git reset或git reset –hard 发生了什么：git reset将你的仓库纪录一直回退到指定的最后一个SHA代表的提交，那些提交就像从未发生过一样。默认情况下，git reset会保留工作目录（working directory）。这些提交虽然消失了，但是内容还在磁盘上。这是最安全的做法，但通常情况是：你想使用一个命令来“撤销”所有提交和本地修改——那么请使用–hard参数吧。 撤销本地后重做 Redo after undo “local” 场景：你已经提交了一些内容，并使用git reset –hard撤销了这些更改（见上面），突然意识到：你想还原这些修改！ 使用撤销命令：git reflog和git reset, 或者git checkout 发生了什么：git reflog是一个用来恢复项目历史记录的好办法。你可以通过git reflog恢复几乎任何已提交的内容。 你或许对git log命令比较熟悉，它能显示提交列表。git reflog与之类似，只不过git reflog显示的是HEAD变更次数的列表。 一些说明： 只有HEAD会改变。当你切换分支时，用git commit提交变更时，或是用git reset撤销提交时，HEAD都会改变。但当你用git checkout –时， HEAD不会发生改变。（就像上文提到的情形，那些更改根本就没有提交，因此reflog就不能帮助我们进行恢复了） git reflog不会永远存在。Git将会定期清理那些“不可达（unreachable）”的对象。不要期望能够在reflog里找到数月前的提交记录。 reflog只是你个人的。你不能用你的reflog来恢复其他开发者未push的提交。 因此，怎样合理使用reflog来找回之前“未完成”的提交呢？这要看你究竟要做什么： 如果你想恢复项目历史到某次提交，那请使用git reset –hard 如果你想在工作目录（working direcotry）中恢复某次提交中的一个或多个文件，并且不改变提交历史，那请使用git checkout– 如果你想确切的回滚到某次提交，那么请使用git reset 与分支有关的那些事 Once more, with branching场景：你提交了一些变更，然后你意识到你正在master分支上，但你期望的是在feature分支上执行这些提交。 使用撤销命令：git branch feature, git reset –hard origin&#x2F;master, 和 git checkout feature 发生了什么：你可能用的是git checkout -b来建立新的分支，这是创建和检出分支的便捷方法——但实际你并不想立刻切换分支。git branch feature会建立一个叫feature的分支，这个分支指向你最近的提交，但是你还停留在master分支上。 git reset –hard将master回退至origin&#x2F;master，并忽略所有新提交。别担心，那些提交都还保留在feature上。 最后，git checkout将分支切换到feature，这个分支原封不动的保留了你最近的所有工作。 事半功倍处理分支 Branch in time saves nine场景：你基于master新建了一个feature分支，但是master分支远远落后与origin&#x2F;master。现在master分支与origin&#x2F;master同步了，你期望此刻能在feature下立刻commit代码，并且不是在远远落后master的情况下。 使用撤销命令：git checkout feature和git rebase master 发生了什么：你也许已经敲了命令：git reset（但是没用–hard,有意在磁盘上保存这些提交内容），然后敲了git checkout -b，之后重新提交更改，但是那样的话，你将失去本地的提交记录。不过，一个更好的方法： 使用git rebase master可以做到一些事情： 1.首先，它定位你当前检出分支和master之间的共同祖先节点（common ancestor）。 2.然后，它将当前检出的分支重置到祖先节点（ancestor），并将后来所有的提交都暂存起来。 3.最后，它将当前检出分支推进至master末尾，同时在master最后一次提交之后，再次提交那些在暂存区的变更。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"yarn-cli笔记","date":"2017-05-02T15:18:36.000Z","path":"2017/05/03/yarn-cli笔记/","text":"前一阵看到一句话，搞技术既要仰望星空，又要脚踏实地。特别是前端，三天两头出来新东西。为了跟上时代，趋势。得学。。然而JS&#x2F;CSS最基础的东西也不能落下。想学的的东西太多，坑越挖越多。亚历山大，加油吧（济南·大明湖 2017-04-30）这两天看了看Yarn，其实之前在微信公众号上看过，自己也照着敲了敲。之后就没在意。还是继续用NPM。没有GET到yarn的优势。恰逢看到一篇yarn vs npm的文章，好好学习了一番。facebook在技术领域的号召力也是没谁了。光看star数都快赶上老大哥npm了。 为什么用yarn？正如官网所说：**FAST, RELIABLE, AND SECURE **。 相比NPM，yarn缓存他下载下来的每一个包，无需重复下载。提高了资源利用率。超级可靠！由于国内网络的特殊原因。有时候npm下载依赖的时候，不能保证包的完整性。会出现很多的“坑”！yarn的话，在每一个安装包的执行前使用校验码验证包的完整性。就不会面对那些坑了。还有一个就是目录下的lock文件。Yarn 使用一个格式详尽但简洁的 lockfile 和一个精确的算法来安装，能够保证在一个系统上的运行的安装过程也会以同样的方式运行在其他系统上。 命令：命令 操作 参数 标签yarn add 添加依赖包 包名 –dev&#x2F;-Dyarn bin 显示yarn安装目录 无 无yarn cache 显示缓存 列出缓存包：ls，打出缓存目录路径：dir，清除缓存：clean 无yarn check 检查包 yarn clean 清理不需要的依赖文件 yarn config 配置 设置：set ， 删除：delete， 列出：list [-g | –global]yarn generate-lock-entry 生成锁定文件 无 无yarn global 全局安装依赖包 yarn global &lt;add&#x2F;bin&#x2F;ls&#x2F;remove&#x2F;upgrade&gt; [–prefix] –prefix 包路径前缀yarn info 显示依赖包的信息 包名 –json：json格式显示结果yarn init 互动式创建&#x2F;更新package.json文件 无 –yes&#x2F;-y：以默认值生成package.json文件yarn install 安装所有依赖包 –flat：只安装一个版本；–force：强制重新下载安装；–har：输出安装时网络性能日志；–no-lockfile：不生成yarn.lock文件；–production：生产模式安装（不安装devDependencies中的依赖）yarn licenses 列出已安装依赖包的证书 ls：证书列表；generate-disclaimer：生成免责声明 yarn link 开发时链接依赖包，以便在其他项目中使用 包名 yarn login 保存你的用户名、邮箱 yarn logout 删除你的用户名、邮箱 yarn list 列出已安装依赖包 –depth&#x3D;0：列表深度，从0开始yarn outdated 检查过时的依赖包 包名 yarn owner 管理拥有者 ls&#x2F;add&#x2F;remove yarn pack 给包的依赖打包 –filename yarn publish 将包发布到npm –tag：版本标签；–access：公开（public）还是限制的（restricted）yarn remove 卸载包，更新package.json和yarn.lock 包名 yarn run 运行package.json中预定义的脚本 yarn self-update yarn自身更新–未实现 yarn tag 显示包的标签 add&#x2F;rm&#x2F;ls yarn team 管理团队 create&#x2F;destroy&#x2F;add&#x2F;rm&#x2F;ls yarn test 测试 &#x3D; yarn run test yarn unlink 取消链接依赖包 yarn upgrade 升级依赖包 yarn version 管理当前项目的版本号 –new-version ：直接记录版本号；–no-git-tag-version：不生成git标签 yarn why 分析为什么需要安装依赖包 包名&#x2F;包目录&#x2F;包目录中的文件名","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"yarn","slug":"yarn","permalink":"http://yoursite.com/tags/yarn/"}]},{"title":"Vuex学习笔记","date":"2017-04-23T09:53:30.000Z","path":"2017/04/23/Vuex学习笔记/","text":"什么是Vuex？ 专门为Vue开发的状态管理模式。采用集中存储管理应用的所有组件状态。在没有用Vuex的时候，我们在进行组件化开发时，数据（也就是状态一般都分散在各个组件中。加入我们要使用这些状态是，我们就得在不同组件中去取状态值，然后进行状态修改，最后还要相互读取对方状态值。父子组件中：我们可以通过事件触发&#x2F;props进行状态传递。子组件之间：由于Vue本身组件之间有作用域，他们之间无法相互通信。这里就必须用单一时间管理（event bus）或者在所有组件和Vue对象下使用一个统一的Object作为数据，来实现。（实质：引用）。 如果项目较小还好，中大型项目，组件通信复杂频繁的时候，这两种方式管理起来就会十分麻烦，而且容易出错。 有了Vuex，它将数据单独放在一个store里，并提供给外部操作内部数据的方法。让我们能更好的管理项目里的状态。这也是Vuex出现的意义吧。就像官网说的： Flux 架构就像眼镜：您自会知道什么时候需要它 正文基本就是按官网的教程撸了一遍。记录一下自己觉得重要的内容。 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)。当然，在使用Vuex的同时，各个组件仍保有局部的状态： 使用Vuex，并不意味着你需要将所有的状态放入Vuex。下面我们来按搭建一个小例子： 源码：https://github.com/laclys/vuex-demo 在Vue脚手架里面，在main.js中： 12345678910111213141516import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;new Vue(&#123; el: &#x27;#app&#x27;, store, render: h =&gt; h(App)&#125;) 这里我们就创建了一个最简单的store，并且挂载在了Vue实例上。配置其实和vue-router挺像的。State：就是单一状态树，将我们需要管理的状态在这里定义。Mutations：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。要想在组件中使用。由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态。 1234computed: &#123; count() &#123; return this.$store.state.count; &#125; 通过要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法。在组件中： 12345 methods: &#123; increment() &#123; this.$store.commit(&#x27;increment&#x27;); &#125;&#125; Getters：这个在上面的例子没有涉及到。我们可以认为Getters是Vuex在store中的计算属性。（Getters 接受 state 作为其第一个参数） 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;...&#x27;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 组件中调用： 12345computed: &#123; doneTodos () &#123; return this.$store.getters.doneTodos &#125;&#125; Actions: 类似于 mutation，不同在于：1)Action 提交的是 mutation，而不是直接变更状态。2)Action 可以包含任意异步操作。 Mutations中对状态的操作只能是同步操作，不能是异步操作。 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&#x27;increment&#x27;) &#125;, 1000) &#125;&#125; 在组件中： 12345methods: &#123; incrementAsync() &#123; this.$store.dispatch(&#x27;incrementAsync&#x27;); &#125; &#125; 说到异步，当然是支持promise以及 async &#x2F; await 这个 JavaScript 即将到来的新特性：这里说一下promise： store.dispatch 可以处理被触发的action的回调函数返回的Promise，并且store.dispatch仍旧返回Promise 12345678decrementAsync(&#123;commit&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&#x27;decrement&#x27;); resolve(); &#125;,1000) &#125;)&#125; 组件中 我们就可以用链式then了： 123456decrementAsync() &#123; this.$store.dispatch(&#x27;decrementAsync&#x27;).then(() =&gt; &#123; // 执行完decrementAsync,之后执行： console.log(&#x27;decrementAsync执行完了&#x27;); &#125;);&#125; 之后还有一个核心概念叫做Modules，顾名思义模块化。当项目非常的庞大，那么状态可能本身还需要进行分模块分类管理，这个时候就需要用到模块了。这里就不再赘言了。 以上","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}]},{"title":"VueJS组件化开发实践总结","date":"2017-04-09T16:31:18.000Z","path":"2017/04/10/VueJS组件化开发实践总结/","text":"前言接触Vuejs，好一阵了。清明节前在慕课网学了一门课。前前后后花了40多个小时琢磨，搭建起了组件化开发的饿了么SPA。这40小时收获了很多，也踩了不少坑。这里总结一下。 源码： https://github.com/laclys/vueApp 技术栈VueJS+Vue-resource+Vue-router+Sass+webpack+ES6 具体细节目录结构 common: 公共文件，包含图标字体文件、一些公共JS方法、Sass的mixin(这里包含移动端一像素、移动端DPR等，后面再提)components：公共组件 包含： cartcontrol:页面底部购物车组件 food：商品详情也组件 goods：商品列表页组件 header：头部组件 ratings：评论列表页组件 seller：商家页组件 shopcart：购物车组件 split：空隙行组件 star：评价星星组件App.vue: 页面入口app组件（组件头头，所有组件都依附于它。)main.js: VueJs入口文件,加载路由,公共组件,组件状态。 收获比较零散一条一一条总结： ​Vue的核心思想就是数据驱动，省去了操纵DOM的步骤，我们所做的一切都是为了改变数据。数据（model）改变&#x2F;驱动视图（view）自动更新。 组件化的意义：扩展HTML元素，封装可重用的代码。 DPR–量化屏幕的物理分辨率和显示清晰度。例如iphone6的DPR为2，6 plus&#x2F;7是3。一般UI给的psd图都是基于DPR为2做的，所以移动端的设计稿，像素尺寸都是两倍或三倍。（这里提一下一般只针对ios，安卓采用1倍布局方案） 移动端实现1px：利用伪类+y轴缩放。味蕾相对于元素绝对定位后，给伪类1px的边框，然后根据设备最小dpr进行scaleY。1234567891011121314151617181920212223242526272829303132@mixin border-1px($color) &#123; position: relative; &amp;:after &#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid $color; content: &#x27;&#x27;; &#125;&#125;// DPR1.5时候@media (-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5) &#123; .border-1px &#123; &amp;:after &#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;// DPR2时候@media (-webkit-min-device-pixel-ratio:2),(min-device-pixel-ratio:2) &#123; .border-1px &#123; &amp;:after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125; ​Vue组件中不能直接使用src，要通过v-bind绑定使用。 CSS消除inline-block下两个行间样式之间的留白。两种办法一种是两个标签不换行紧紧贴着；二是给他们的父级加font-size：0。这样就可以解决了。 iphone一般的默认字体：‘PingFang SC’, ‘STHeitiSC-Light’, ‘Helvetica-Light’, arial, sans-serif; 省略号：（写过好多遍）123white-space:nowrap;overflow:hidden;text-overflow:ellipsis; CSS sticky footer布局（实现底部内容随着内容长度而变化。）：http://www.w3cplus.com/css3/css-secrets/sticky-footers.html IOS专有的模糊背景属性：backdrop-filter: blur(10px); ​垂直居中：父级用display: table, 子级display：table-cell；vertical-align：middle； Vue异步赋值。一般需要dom加载完成后操作dom时使用（动态更新数据）：this.$nextTick(()&#x3D;&gt;{}); css黑魔法：padding-top：100%（相对于宽度来计算padding） 兼容iphone5小屏幕时：123@media only screen and (max-width:320px)&#123; &#125; 注意驼峰命名和连字符命名 总结通过这次组件化开发事件，收获不仅仅是vue这门语言，还有很多规范的编程习惯。ESlink的使用、css结构格式、命名规范···Vue很多技术细节，还是需要好好琢磨文档。抽时间再学一下Vuex。webpack真的很方便。不过吐槽一下vue-loader根本没有处理.vue文件里面的内容，他只是告诉你应该由其他的方式来loader来处理这个文件。 就这样吧。又是一年樱花季，来一张去年的照片解解馋吧&#x3D;。&#x3D;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Webpack2小试","date":"2017-03-29T13:08:52.000Z","path":"2017/03/29/Webpack2小试/","text":"前端的水很深很杂，因而前端相关的工具也像雨后春笋一个一个的冒出来。最近大热的应该就数webpack–这个模块化解决方案工具。 Gulp&#x2F;Grunt VS Webpack首先这三者都是前端工具，都等让我们高效自动化的解决一些问题。但实质上webpack和Gulp&#x2F;Grunt有本质的区别。 先谈谈前者。Gulp&#x2F;Grunt两者的区别，暂且不在这说了。用处的话，两者可以帮我们自动刷新页面，压缩css&#x2F;js&#x2F;html以及便宜sass&#x2F;less。简单的说只要你配置你需要的插件，就可以把以前需要手动做的事情让它帮你完成。那官方的话来说就是—-TaskRunner。可以做到node能做到的任何事。 而Webpack，简单的说：就是一个针对Javascript代码模块的打包工具。作为一个 module bundler 存在。在我的理解来看：webpack 更多的是用来打包前端代码。 webpack 并不暴露文件处理的细节，你只是把一堆文件丢给它，告诉它用什么 loader 来处理什么文件，然后就可以等着输出了。 webpack相比gulp来说功能单一一些，更简化一些。当然两者也有交际例如什么预编译,压缩代码之类的。 How to use Webpack2首先需要npm install 相关的模块： npm i webpack –save-dev 之后在根目录下建一个webpack.config.js,来配置webpack。 1234567var webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#x27;./src/app.js&#x27;, output: &#123; path: __dirname + &#x27;/dist&#x27;, filename: &#x27;js/[name].bundle.js&#x27;, &#125;&#125; entry为webpack寻找的入口。output便是处理之后输出文件的地址。(__dirname这里指根目录)在entry中的js文件里我们可以通过import或者require引入依赖。源文件都放在了src目录中:└─src └─www ├─css ├─img └─js在src目录下有一个app.js。如下： 1import &#x27;./www/js/js-test.js&#x27; 分别调用了css&#x2F;js文件夹的内容。test-css.css 1234567891011121314*&#123; margin: 0; padding: 0;&#125;div&#123; width: 100px; height: 100px; /*background: red;*/ background: url(../img/test-img.jpg); background-size: contain;&#125;.flex&#123; display: flex;&#125; js-test.js 123function a()&#123; console.log(12345);&#125; 之后在命令行就可以运行webpack了。不过在这之前 我们可以在package.json文件中对webpack命令进行一下小配置：在script下添加 “webpack”: “webpack –config webpack.config.js –progress –display-modules –colors –display-reasons” 分别是显示过程 显示模块 高亮 以及执行原因 1npm run webpack 在dist文件夹就生成了 打包好的js文件：main.bundle.js。 Loaders前面 说的都是关于打包JS代码。我们的webpack当然能力不仅仅是这些。通过各种文件的loader，我们可以处理各种文件。。前提是我们将他传入js代码中。比如处理css的css-loader&#x2F;style-loader。css预处理loader：postcss-loader。处理sass的sass-loader。图片文件的file-loader和url-loader。这些loader我们都可以通过npm i 来下载使用。这里简单说一个css-loader&#x2F;style-loader。首先我们要在app.js中引入css文件 1import &#x27;./www/css/test-css.css&#x27;; 之后在webpack.config.js中配置插件 12345module: &#123; loaders: [&#123; test: /\\.css$/, loader: &#x27;style-loader!css-loader&#x27;//从右向左执行。先执行css-loader，再执行style-loader &#125; 之后在命令行运行一下就ok了。webpack的使用很灵活处理ES6&#x3D;&gt;ES5。给css代码加前缀····github：https://github.com/laclys/webpack2_Demo/tree/master/webpack0329 以上~","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Angular1.5到Angular1.6的JSONP交互相关的设置及小Demo","date":"2017-03-23T15:35:28.000Z","path":"2017/03/24/Angular1.5到Angular1.6的JSONP相关的设置及小Demo/","text":"不管学习那个前端框架（其实后端也是）都回避不了，数据的交互。在交互中在重要的两个就是AJax以及跨域的JSONP。 Angular–Ajax交互在之前的博文中开头先跑题一下说说第一种Angular的Ajax交互。废话不多说上代码： 12345678910111213var app = angular.module(&#x27;app&#x27;, []); app.controller(&#x27;show&#x27;, function ($scope, $http) &#123; $scope.get = function () &#123; $http(&#123; method: &#x27;GET&#x27;, url: &#x27;a.txt&#x27; &#125;).then(function (res) &#123; alert(res.data); &#125;, function () &#123; &#125;) &#125; &#125;); 这里在文件夹内建了一个a.txt文件里面随便打了一些数字。在angular包裹的控制器中调用$http，设置url以及所使用的method。如果有其他数据就加一个data属性。这样向后台发的信息就制作好了。是不是和JQ很像。之后then后面两个函数一次对应JQ中的success和error函数。这里。我们当它成功获取a.txt文件中数据时，console.log一下.数据就在我们控制台显示了出来。 Angular–JSONP交互下面开始说今儿的重点JSONP交互。Angular中JSONP的操作也是基于$http方法中的。由于前端框架的高速版本变化。在JSONP这一块1.5版本和1.6版本有很大的不同。下面就来详细说一下。 Angular1.5及以下版本在1.5及以下版本里。是通过在url中callback&#x3D;’JSON_CALLBACK’。来进行JSONP的操作。这里还是那代码举例。还是之前JQ&#x2F;原生JS那块在在输入框输入字符，通过JSONP调用百度联想功能，列出索引联想的那个例子。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;app&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;angular1-5-6.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&#x27;app&#x27;,[]); app.controller(&#x27;show&#x27;,function($scope,$http)&#123; $scope.arr=[]; $scope.msg=&#x27;&#x27;; //当msg变的时候 $scope.$watch(&#x27;msg&#x27;,function()&#123; $http(&#123; method:&#x27;JSONP&#x27;, url:&#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;+$scope.msg+&#x27;&amp;cb=&#x27;+&#x27;JSON_CALLBACK&#x27; &#125;).then(function(res)&#123; //成功的函数 $scope.arr=res.data.s; &#125;,function()&#123; //失败的函数 &#125;) &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=&quot;show&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;msg&quot;/&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;v in arr&quot;&gt;&#123;&#123;v&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 和之前Ajax的调用很像。区别就是method设置为‘JSONP’以及url使用了 url:’https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su? wd&#x3D;’+$scope.msg+’&amp;cb&#x3D;’+’JSON_CALLBACK’期间$scope.ms’为$scope.$watch监控输入栏变化的值，进行实时监控。在线Demo：https://laclys.github.io/HTML-CSS-JS_practice/angular/JSONP_baidu_keywords1-5-6.html Angular1.6下面开始说最新的1.6版本。一开始做练习的时候用的1.6.3版本，怎么也出不来，换成了1.5.6就ok了。之后各种查资料，搜索1.6怎么使用。官网是这么说的1.5之后不能再用JSON_CALLBACK了，并且要把JSONP的url加入白名单。看完第一感觉是懵逼的。说实话网上这一块资料比较少，也没有例子。之后捣鼓好半天研究了出来。1.6中$watch函数中得这么写： 12345678910111213141516var url = &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#x27;; var temp = $scope.msg; console.log(temp); $http.jsonp( $sce.trustAsResourceUrl(url), &#123; params: &#123; wd: temp &#125;, jsonpCallbackParam: &#x27;cb&#x27; &#125; ).then(function (res) &#123; // alert(res.data.s) $scope.arr = res.data.s; &#125;, function (res) &#123; alert(&#x27;res&#x27;) &#125;); 使用’$http.json’。要处理的url的callback之前通过’$sce.trustAsResourceUrl(url)’，添加到白名单。之后我们的参数要放在params中。最后 jsonpCallbackParam: ‘cb’。Demo如下：https://laclys.github.io/HTML-CSS-JS_practice/angular/JSONP_baidu_keywords.html 1.6网上的资料还是太少，文档有些含糊纠结了我好半天。一顿乱试。还好最后成功了。不然纠结死我&#x3D; &#x3D;。angular这块水很深，还是要多多啃文档才行~","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"交互","slug":"交互","permalink":"http://yoursite.com/tags/%E4%BA%A4%E4%BA%92/"}]},{"title":"小试NodeJS的express进行前后端数据交互","date":"2017-03-13T17:09:02.000Z","path":"2017/03/14/小试NodeJS的express进行前后端数据交互/","text":"今儿小试了一下NodeJs的express框架，在这说一说如何通过express进行前后台的数据交互。 这几年nodeJs大火，有很多原因。其中最重要的我想就是和前台同为JS语言，在交互上比其他后台语言配合起来更爽一些。 这里就简要的讲一下通过express框架进行前后端数据交互。express是一个很轻量级的nodeJS框架。使用起来也比较简单。要运用这个框架首先我们需要先将它下载下来： 1npm install express --save （后面加了–save，是为了把模块保存到配置文件中，当项目移植的时候只需要npm install 就会把所有依赖的模块下载下来） 之后就是搭建服务器了。创建一个js文件1, 首先引入框架 1const express=require(&#x27;express&#x27;); 2, 创建、搭建服务器 1let server=express(); 3,设置一个端口进行监听 1server.listen(2333); 端口号随便设，只要不超过65535就好4,设置中间量这里我们可以使用三种依次是get&#x2F;post&#x2F;use。这里我用的是get方式 12345server.get(&#x27;/a&#x27;,(request, response)=&gt; &#123; console.log(request.query); response.send(&quot;永远18岁&quot;); response.end(); &#125;); 5,设由于三次握手，我们还需要访问静态的html，让其得到后台的处理结果。所以我们需要再引入一个模块： 1npm install express-static --save 并在js中添加： 1const static = require(&#x27;express-static&#x27;); 有了它，我们就能访问html这类静态文件了。6,设置文件权限。将前后端分离开来，前端文件都放在一个叫‘www’的文件夹中。 1server.use(static(&#x27;www&#x27;)); 7，前端交互（运用了JQ打包好的Ajax,这里就不细说了） 123456789101112131415&lt;script src=&quot;jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url:&#x27;/a&#x27;, type:&#x27;POST&#x27;, data:&#123; name:&#x27;zyy&#x27;, age:18 &#125;, success:function(data)&#123; console.log(data); &#125;, error:function()&#123;&#125; &#125;); &lt;/script&gt; 前台向后台发送data（永远18岁），在后台接收到了数据，通过console.log(request.query);打印出来。另外post的话，和get不同。先下载 1npm i body-parser --save 再加上下面两行代码，再在里面用：console.log(request.body);打印 12const body=require(&#x27;body-parser&#x27;);server.use(body.urlencoded()); 随后后台通过response.send(“永远18岁”);又向前台做出回应。前台通过Ajax， 1234success:function(data)&#123; console.log(data);//得到这条回应，并在浏览器控制台打印出来 //“永远18岁” &#125; 这个就是基于NodeJs express框架 前后端数据交互3次握手典型的小Demo。 以上！","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}]},{"title":"深入理解javascript原型和闭包笔记总结","date":"2017-03-12T14:33:40.000Z","path":"2017/03/12/深入理解javascript原型和闭包笔记总结/","text":"这两天发现一系列很好很棒的javascript原型和闭包深入理解的文章。http://www.cnblogs.com/wangfupeng1988/p/3977924.html 在javascript的学习中，个人认为最容易犯错，坑最多的就是原型链和闭包这一块。原型链这一块也算是js的一大特色，闭包捏则是大量运用于JQ的源码中。很有必要好好总结学学习一番。由于很重要，也绕不开。结合文章，总结了一波这一块的知识点，由于都记在了本本上，这里来一波图片，随时可以参考。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"icomoon图标","date":"2017-02-26T15:10:26.000Z","path":"2017/02/27/icomoon图标/","text":"周末研究布局，遇到了获取图标的问题。在之前遇到图标第一时间想到的是切图，在页面放图片。在慕课网看了关于性能优化的雅虎军规之后发现这样很不好。遂翻了翻大厂们的页面，使用的都是字体图标（大家都知道，字体图标相比图片省了太多资源大大减少请求数量不说，任意缩放也不会失真。）搜索了一下发现了icomoon这个好东西。 使用icomoon借用的是一个在线生成网站：https://icomoon.io/app/#/select里面有已经存在的可以直接选用，当然也可以添加.svg图片。在这里，我使用了它现有的一个搜索放大镜小图标。 之后点击“generate font”进行生成（可以自由改名），下载即可。下载下来的fonts文件夹放入项目中，再将style.css中的样式放入css中即可：我这里的搜索小图标在样式里添加： 12345678910111213141516171819202122232425262728@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;../fonts/icomoon.eot?jbld9x&#x27;); src: url(&#x27;../fonts/icomoon.eot?jbld9x#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;../fonts/icomoon.ttf?jbld9x&#x27;) format(&#x27;truetype&#x27;), url(&#x27;../fonts/icomoon.woff?jbld9x&#x27;) format(&#x27;woff&#x27;), url(&#x27;../fonts/icomoon.svg?jbld9x#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125;[class^=&quot;icon-&quot;], [class*=&quot; icon-&quot;] &#123; /* use !important to prevent issues with browser extensions that change fonts */ font-family: &#x27;icomoon&#x27; !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-search:before &#123; content: &quot;\\e986&quot;;&#125; html中调用就好： 当然我们可以自由的设置它的字体大小颜色。是不是比图片好太多了。 通过以上步骤，图标得以显示","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"JSONP的原生实现和JQ实现(下)","date":"2017-02-22T17:03:44.000Z","path":"2017/02/23/JSONP的原生实现和JQ实现(下)/","text":"JQ实现方式：JQ实现JSONP的时候看起来和ajax调用方式很像，目的也一样，都是请求url，染过获得服务器的数据之后进行处理。但两者完全是两个不同的东西。只是JQ这个框架将jsonp作为ajax的一种形式进行了封装。实质上：ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。 ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。话不多说，下边是jq的实现，用过console.log得到目标数据： 1234567891011121314151617181920$(function () &#123; $(&#x27;#inp&#x27;).keypress(function () &#123; var str = $(this).val(); $.ajax(&#123; url: &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#x27;, data: &#123; wd: str &#125;, dataType: &#x27;jsonp&#x27;, jsonp: &#x27;cb&#x27;, success: function (data) &#123; console.log(data); &#125;, error: function () &#123; &#125; &#125;); &#125;); &#125;); 以上！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"jsonp","slug":"jsonp","permalink":"http://yoursite.com/tags/jsonp/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JSONP的原生实现和JQ实现(上)","date":"2017-02-22T17:01:18.000Z","path":"2017/02/23/JSONP的原生实现和JQ实现(上)/","text":"JSONPJSONP，全称：JSON with padding乍一看应该是和用来数据解析描述的JSON的某个远房亲戚。通过学习，这两者本质上完全是不同的东西。 JSONP的概念在这就不赘言。自己的理解，由于Ajax直接请求文件数据时，跨域无权访问（为了安全）。为了解决跨域问题，我们发现在页面调用JS文件时不受跨域影响（例如，我们在任意文件中都可以引入jq文件，从而使用jq开发页面），因此通过把数据装在一个js格式文件里，在客户端进行处理。这就是JSONP的原理。JSONP允许用户传递一个callback参数给服务器，之后服务器返回数据时通过这个参数的函数包裹上数据传给客户端。 下面不多说废话，下面用原生和jq分别写两个小获取baidu联想词条的小demo。想要的效果就是当我在搜索条输入‘a’时，出现下拉联想列表（baidu的） 首先是原生实现方式：我们先通过浏览器得到这一个数据请求。（在调试窗口的network中）得到了请求： 1Request URL:https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a&amp;json=1&amp;p=3&amp;sid=1424_21114_17001_21930_22036&amp;req=2&amp;csor=1&amp;cb=jQuery1102023194193176203193_1487780037910&amp;_=1487780037913 经过分析wd&#x3D;a是我们联想的a（故这儿可以放我们想要联想的值）；cb是callback回调函数。把其他的都干掉：https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a&amp;cb=showshow随便起的回调函数名字。之后代码如下： 1234567891011121314151617181920function show(data) &#123; var oUl = document.getElementById(&#x27;ull&#x27;); var arr = data.s; oUl.innerHTML=&#x27;&#x27;; for(var i=0;i&lt;arr.length;i++)&#123; var oLi=document.createElement(&#x27;li&#x27;); oLi.innerHTML=arr[i]; oUl.appendChild(oLi); &#125;&#125;window.onload = function () &#123; var oT = document.getElementById(&#x27;inp&#x27;); oT.oninput = function () &#123; var str = oT.value; var oScript = document.createElement(&#x27;script&#x27;); oScript.src = `https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=$&#123;str&#125;&amp;cb=show`; document.head.appendChild(oScript); &#125;&#125;; html 1234567&lt;body&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; id=&quot;inp&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;baidu&quot; id=&quot;inp&quot;&gt; &lt;ul id=&quot;ull&quot;&gt; &lt;/ul&gt;&lt;/body&gt; 当文本框有键盘输入事件时，我们在head标签下面动态的创建了一个script标签，标签的src中是放入了我们的请求wd，之后cb（回调函数）show来接受返回的data。并存储在ul的li下。效果如下：","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"jsonp","slug":"jsonp","permalink":"http://yoursite.com/tags/jsonp/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS中的cookie,localStorage和sessionStorage","date":"2017-02-20T16:00:38.000Z","path":"2017/02/21/JS中的cookie,localStorage和sessionStorage/","text":"说到cookie通俗一点就是服务器留在用户计算机中的小文件。在JS中创建cookie很简单，比如：document.cookie&#x3D;123 这样就存储了一条没有名字的cookie。cookie的存储都是字符串，如果存储一条名字是name，值是‘lac’的cookie只需要：document.cookie&#x3D;’name&#x3D;lac’即可！取出存储的cookie也只需要：document.cookie就可以取出全部的cookie字符串了。cookie里除了名字和值还有expires和path很重要。 expires 默认是session：浏览器和服务器进行的一次通话 浏览器关闭一次会话结束。当然也可以设置时间。expires&#x3D;事件对象； path cookie存储的位置 需要注意的是：内层文件存的cookie外层文件取不到，内层文件中可以取到外层文件的cookie在一般工作中，一套cookie存储在一层目录中便于管理。即：path&#x3D;&#x2F;；下面是自己封装的setCookie(),getCookie()以及removeCookie(); code如下： 123456789101112131415161718192021222324252627//设置cookiefunction setCookie(sName, sValue, iDay) &#123; if (iDay) &#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + iDay); document.cookie = `$&#123;sName&#125;=$&#123;sValue&#125;;path=/;expires=$&#123;oDate&#125;`; &#125; else &#123; document.cookie = `$&#123;sName&#125;=$&#123;sValue&#125;;path=/`; &#125;&#125;// 获取cookiefunction getCookie(sName) &#123; var str = document.cookie; var arr1 = str.split(&#x27;; &#x27;); for (var i = 0; i &lt; arr1.length; i++) &#123; var arr2 = arr1[i].split(&#x27;=&#x27;); if (arr2[0] == sName) &#123; return arr2[1]; &#125; &#125; return &#x27;&#x27;;&#125;//删除coocookiefunction removeCookie(sName)&#123; setCookie(sName,&#x27;&#x27;,-1);&#125; 有了cookie就能解决很多问题了（ps：cookie操作必须在服务器环境）例如直接自己做过拖拽小例子。现在每次打开小方块儿都在起始位置，关闭浏览器之后再打开。没有保存关闭之前他所在的位置。现在有了cookie。就很简单可以实现关闭页面再打开依然是我们上一个关闭前的位置。code：https://laclys.github.io/HTML-CSS-JS_practice/JS/cookie/drag.html在抬起鼠标事件下 1setCookie(&#x27;pos&#x27;, `[$&#123;oBox.offsetLeft&#125;,$&#123;oBox.offsetTop&#125;]`,3); 再在window.onload下获取元素之后，获取出来 12345var arr = eval(getCookie(&#x27;pos&#x27;)); if (arr) &#123; oBox.style.left = arr[0] + &#x27;px&#x27;; oBox.style.top = arr[1] + &#x27;px&#x27;;&#125; 这样在这三天内（cookie设置了保存三天），移动小方块关闭浏览器，再打开小方块都会在关闭前的位置了。 下面再来说说cookie的缺点1, 会过期；2, 容量小（历史问题吧）只有4k,一般小于20条。&#x3D;；3, 每次向服务器发送请求时，都会向服务器发送cookie；（这点很致命） localStorage &#x2F; sessionStorage下面再说说localStorage &#x2F; sessionStorage这两个高级浏览器才拥有的好东西。为什么说是好东西，cookie的缺点全部干掉，变成优点。localStorage： 使用方便 不用封装函数； 5M； 不会向服务器发送请求； 使没有过期； 使用的话： 存： localStorage.setItem(name.value); 取： localStorage.getItme(name); 删除 localStorage.removeItem(name); 全部删除 localStorage.clear();是不是很简单。sessionStorage：和localStorage一样就是在一个会话session中关闭浏览器就消失。使用的话也和localStorage一样： 存： sessionStorage.setItem(name.value); 取： sessionStorage.getItme(name); 删除 sessionStorage.removeItem(name); 全部删除 sessionStorage.clear(); 高级浏览器方法无限好，还是那句话：干掉IE人人有责！ 以上！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"css3 伪类：hover 特性小探索","date":"2017-02-18T13:36:18.000Z","path":"2017/02/18/css3-伪类：hover-特性小探索/","text":"伪类在css3中相对还是很容易理解，也正是因为他很容易理解，平时也不纠结。不过前两天看到这个写法，还是小懵逼了一下： 12.a .b:hover&#123;...........&#125;; .a:hover .b&#123;...........&#125;; 这两个有什么去别捏，不费事就写了两个demo： 第一个：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; float: left; border: 1px solid darkblue; text-align: center; line-height: 100px; &#125; .a .b:hover&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; A &lt;div class=&quot;b&quot;&gt; B &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这是第一种写法的例子，这很好理解，当鼠标移入b时，b的背景颜色变成红色。 第二种：css部分改为了： 123.a:hover .b&#123; background: red;&#125; 这是第二种写法的例子，它所表示的是当鼠标移入a时，b的背景颜色变成红色；同时，当鼠标移入b时，b的背景颜色也会变成红色。（当然b一定要是a的子元素才行！）这样就看出区别了，其实仔细想想，归根结底还是css选择器匹配元素不一致导致的。不能被表象迷惑&#x3D; &#x3D;。 ps：话说prtSc+alt这截图这截不出鼠标，很尴尬&#x3D; &#x3D;。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"JQuery获取浏览器窗口的可视区域高度和宽度,滚动条高度","date":"2017-02-17T09:00:54.000Z","path":"2017/02/17/JQuery获取浏览器窗口的可视区域高度和宽度,滚动条高度/","text":"12345678910alert($(window).height()); //浏览器时下窗口可视区域高度alert($(document).height()); //浏览器时下窗口文档的高度alert($(document.body).height());//浏览器时下窗口文档body的高度alert($(document.body).outerHeight(true));//浏览器时下窗口文档body的总高度 包括border padding marginalert($(window).width()); //浏览器时下窗口可视区域宽度alert($(document).width());//浏览器时下窗口文档对于象宽度alert($(document.body).width());//浏览器时下窗口文档body的高度alert($(document.body).outerWidth(true));//浏览器时下窗口文档body的总宽度 包括border padding marginalert($(document).scrollTop()); //获取滚动条到顶部的垂直高度alert($(document).scrollLeft()); //获取滚动条到左边的垂直宽度","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JS原型与原型链学习笔记","date":"2017-02-10T15:55:00.000Z","path":"2017/02/11/JS原型与原型链学习笔记/","text":"这一周在慕课以及网上搜索，好好学习理解了一下JS的原型&#x2F;原型链。在这里笔记一下自己觉得重要的东西，在这总结一下。 普通对象与函数：JavaScript 中分为普通对象和函数对象。凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。 构造函数：12345678function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name) &#125; &#125;var person1 = new Person(&#x27;Zaxlct&#x27;, 28, &#x27;Software Engineer&#x27;);var person2 = new Person(&#x27;Mick&#x27;, 23, &#x27;Doctor&#x27;); 上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。person1 和 person2 都是 构造函数 Person 的实例 !!!实例的构造函数属性（constructor）指向构造函数。 原型对象：在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）。eg： Person.prototype.constructor &#x3D;&#x3D; Person可以理解为：原型对象（Person.prototype）是 构造函数（Person）的一个实例 .proto:JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__ 的内置属性，用于指向创建它的构造函数的原型对象。对象 person1 有一个 __proto__属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以： person1.proto &#x3D;&#x3D; Person.prototype via internet从而可得到： Person.prototype.constructor &#x3D;&#x3D; Person; person1.proto &#x3D;&#x3D; Person.prototype; person1.constructor &#x3D;&#x3D; Person; 构造器：构造器都是函数对象 “function”。 总结：1,原型和原型链是JS实现继承的一种模型。2,原型链的形成是真正是靠__proto__ 而非prototype 以上！！！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"在Github中演示前端demo","date":"2017-02-07T16:06:08.000Z","path":"2017/02/08/在Github中演示前端demo/","text":"在浏览他人Github时，经常能看到他们的前端项目的Readme.md中，放有在线演示Demo。自己也想实现这样的效果，在网上自己摸索。总结为下文&#x3D;。&#x3D; 需求：一般情况，我们将自己写成的网页上传到github仓库，点进相应的html界面出来的是该文件的代码。他人看起来非常不直观。因此，我们需要一个在线演示demo的平台。 两种方法方法一：这种方法比较简单。通过增加路径前缀的方法，实现在线demo浏览。在github中随便找一个html演示：例如前些天写的瀑布流：HTML-CSS-JS_practice&#x2F;JS&#x2F;瀑布流&#x2F;瀑布流.html。其的页面路径为：https://github.com/laclys/HTML-CSS-JS_practice/blob/master/JS/瀑布流/瀑布流.html 这一大长串。我们只需要在这一大长串地址前面加上http://htmlpreview.github.io/?即可。最后的浏览demo地址为：http://htmlpreview.github.io/?https://github.com/laclys/HTML-CSS-JS_practice/blob/master/JS/瀑布流/瀑布流.html 这种方法看似很简单，可是有缺陷的。会更改css样式，不建议使用。 方法二：普遍采用的一种方法，通过使用Githubpages。首先，在我们需要演示的项目中，增加gh-pages分支（正常情况下只有一个master分支）。把需要演示的页面代码克隆到这个分支上。如果本地实在master分支下工作的，工作完成后，输入命令： git push origin master:gh-pages此命令的意思是把本地master分支的内容推送到远程的gh-pages。如果远程没有gh-pages分支的话，会自动创建该分支假如我们想浏览今儿做成的完美拖拽小demo：HTML-CSS-JS_practice&#x2F;JS&#x2F;拖拽&#x2F;完美拖拽（八个方向）.html我们通过：http:&#x2F;&#x2F;[用户名].github.io&#x2F;[index.html所在目录] 这种方式访问。我的 githubpages为：laclys.github.io（也就是我的blog地址）（如果有index.html,则会直接访问到主页）则最后的浏览地址是：laclys.github.io + HTML-CSS-JS_practice&#x2F;JS&#x2F;拖拽&#x2F;完美拖拽（八个方向）.htmlDEMO最后我们可以将这个地址添加到Readme上面去！ 以上！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"过年这几天","date":"2017-02-03T09:22:08.000Z","path":"2017/02/03/过年/","text":"恍惚间，好久没在国内过年了。在日本的时候每逢除夕夜，叫上几个中国同乡，一起热热闹闹聚一下。吃顿饺子或者去池袋吃个火锅，好不热闹。你二天上班的上班，上学的上学。 今年总算在家过，比小时候的记忆少了一丝年味。除夕夜没有了炮竹，爷爷摔了一跤的，缘由老爸晚上的在奶奶家照顾老人。今年的除夕夜就和老妈两人。老妈说多亏我回来了。不然今年过节就一个人。其实心里蛮难受的，大学以后一年一年和父母生活的时间越来越少。过年期间，见了好几波朋友，吃吃喝喝胖了快十斤。（不得不说还是国内吃的好吃），初一看了部韩 寒的乘风破浪，比起第一部后会无期。韩寒进步了很多，不过故事太过相像于《新难兄难弟》还有东野圭吾的《时生》不多评价。游戏上通关了FF15，第一次公布PV的时候，自己还是的初三学生，一晃十年过去了。20h通关这个新时代的水晶传说，毕竟是大IP，画面音乐都是业界顶尖水准。19章是一个游戏，914章又变成了另一个游戏。游戏素质的如此割裂，虎头蛇尾，作为一个在日厂带过的人，真是感慨万分。也许SE真的尽力了。日厂保守了这么多年，有想法，技术力却被欧美拉开了好远。IT这行，保守真的行不通。 技术方面，还是再看前端。也不知道自己能学到什么程度。努力吧新年给自己顶下目标，天天刷刷慕课网，Github还有就是减少使用社交软件的频率。去年玩得太嗨，今年不管是为了自己还是让父母放心都想努力拼一拼。鸡年，加油！！！除夕夜的大雁塔：","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTML/CSS代码快速编写---Emmet","date":"2017-01-31T11:19:18.000Z","path":"2017/01/31/什么是Emment？/","text":"最近学习前端，一开始用sublime，现在转到vscode上。它们通过安装插件都支持Emmet的HTML语法规则。在这里，一边自己学习一边分享一下啊。 什么是Emment？Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML&#x2F;CSS代码编写的速度。eg：输入!,然后按Tab键： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; html:5 或!：用于HTML5文档类型 html:xt：用于XHTML过渡文档类型 html:4s：用于HTML4严格文档类型 Emmet支持的简写规则 E 代表HTML标签。 E#id 代表id属性。 E.class 代表class属性。 E[attr&#x3D;foo] 代表某一个特定属性。 E{foo} 代表标签包含的内容是foo。 E&gt;N 代表N是E的子元素。 E+N 代表N是E的同级元素。 E^N 代表N是E的上级元素。 后代缩写：nav&gt;ul&gt;li 12345&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 兄弟缩写：div+p+bq 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt; 上级缩写：div+div&gt;p&gt;span+em^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt; 分组：()缩写：div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 缩写：(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 乘法：*缩写：ul&gt;li*5 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 自增符号：$缩写：ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 缩写：ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt;&lt;/ul&gt; ID和类属性缩写：form#search.wide 1&lt;form id=&quot;search&quot; class=&quot;wide&quot;&gt;&lt;/form&gt; 自定义缩写：p[title&#x3D;”Hello world”] 1&lt;p title=&quot;Hello world&quot;&gt;&lt;/p&gt; 文本：{}缩写：a{Click me}1&lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt;差不多常用的就这些。&#x3D;。&#x3D;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Emmet","slug":"Emmet","permalink":"http://yoursite.com/tags/Emmet/"}]},{"title":"VSCODE1.8下TypeScript（win10）","date":"2017-01-30T17:10:40.000Z","path":"2017/01/31/VSCODE1.8下TypeScript（win10）/","text":"TypeScriptTypeScript是微软开发的一个Js的超集，TypeScript兼容JavaScript，可以载入JavaScript代码然后运行。完全支持ES6规范。TypeScript也是Google公司推出前端框架Angular2的开发语言。(可以说是Google，微软强强联手吧。一直想学Angular框架自然的学学这TypeScript) 由于TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。首先就是搭建开发环境。 compier编译器分两种一种是在线编译器，在百度搜索typescript，就可以找到：http://www.typescriptlang.org/play/index.html可以将TS代码转化成JS代码。另一种就是本地编译器。由于自己一直用vscode这一轻量级ide。网上资料不是很对。就来码一下自己的安装配置过程。 Go：本文基于node.js下进行下载最新TypeScript： npm install -g typescript现在最新的是2.1更新TypeScript： npm update -g typescript查看当前版本： tsc -v安装完typescript之后打开vscode，创建一个workspace并在其下添加一个tsconfig.json。设置以下参数： 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;noImplicitAny&quot;: false, &quot;module&quot;: &quot;amd&quot;, &quot;removeComments&quot;: false, &quot;sourceMap&quot;: true &#125;&#125; 之后创建一个main.ts测试:（我们使用在线编译器typescriptlang下的helloworld代码） 12345678910111213141516171819class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter = new Greeter(&quot;world&quot;);let button = document.createElement(&#x27;button&#x27;);button.textContent = &quot;Say Hello&quot;;button.onclick = function() &#123; alert(greeter.greet());&#125;document.body.appendChild(button); 之后按下快捷键「Ctrl+Shift+B」：提示‘配置任务运行程序’。点击选择tsconfig.json 创建TypeScript项目。之后生成一个.vscode文件夹。里面有该项目的运行的配置设置：完成设置。再次按下快捷键「Ctrl+Shift+B」，生成main.js和main.js.map文件。大功告成。Visual Studio Code编译TypeScript,并且输出对应的JavaScript档案！ ps：春节就这么过完了&#x3D;。&#x3D;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"通过class名获取元素（解决IE8不兼容问题）","date":"2017-01-16T12:38:08.000Z","path":"2017/01/16/通过class名获取元素（解决IE8不兼容问题）/","text":"Js中获取元素通常有三种方式通过ID（getElementById）,标签（getElementsByTagName）以及CLASS名（getElementsByClassName）。前两种方式最为常用，在Chrome，FireFox以及低版本IE8下都好使（win10自带的ie只支持模拟到IE8，再古老的版本直接忽略好了）。可是CLASS名获取元素时，在IE8下出现这样的问题：对象不支持“getElementsByClassName”属性或方法 因此在ie8下使用CLASS名获取元素时，需要我们自行解决兼容问题。eg：在下面这个简单的无序列表，有序列表嵌套li的简单HTML页面中，让ul标签下的class为red的li标签背景变红 123456789101112&lt;body&gt; &lt;ul&gt; &lt;li class=&quot;red&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class=&quot;red2 blue&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class=&quot;red&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; 解决方案如下： 12345678910111213141516171819202122232425262728//oParent：获取元素的父级对象；sClass：要获取的CLASS名（字符串）function getByClassName(oParent, sClass) &#123; //当getElementsByClassName方法可以用时，直接使用这个方法 if (oParent.getElementsByClassName) &#123; return oParent.getElementsByClassName(sClass); &#125; else &#123; var aEl = oParent.getElementsByTagName(&#x27;*&#x27;); var arr = []; for (var i = 0; aEl.length; i++) &#123; //声明一个临时数组，把每一个元素获取过来的className存起来 var temp = aEl[i].className.split(&#x27; &#x27;); //在temp中找class里包括red的元素，如果存在则true。让 //这个元素背景色变红 if (findInArr(sClass, temp)) &#123; arr.push(aEl[i]); &#125; &#125; return arr； &#125;&#125;//函数：查找item在arr中存不存在function findInArr(item, arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == item) &#123; return true; &#125; &#125; return false;&#125; github：github.com&#x2F;laclys&#x2F;HTML-CSS-JS_practice&#x2F;blob&#x2F;master&#x2F;JS&#x2F;classname获取 封装（对应ie8–）.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JavaScript知识点总结1","date":"2017-01-14T16:59:08.000Z","path":"2017/01/15/JavaScript知识点总结/","text":"近期学习js知识的总结，，还会有2，3，4···· 事件：onclick,onmouseover,onmouseout,onmouseup,onmousedown,onchange，onload 获取元素：通过id获取元素 ：document.getElementById(); 通过Tag获取元素： document.getElementsByTagName(); 函数：定义函数：function 函数名(){} 执行函数：谁调用了这个函数就在谁那里执行。 变量：var 变量名&#x3D;变量值 “.”:只能操作已存在的属性。 “[]”:可以接受一个变量，点能够操作的中括号都能操作。 循环：for： 123456//初始值var i=0，//条件i&lt;6，//自增i++ 代表每次加1for(var i=0;i&lt;6;i++)&#123; alert(i);&#125; while: 12345678//初始值var i=0;//条件while(i&lt;6)&#123; alert(i); //自增 i++;&#125; this：表示当前发生事件的元素。 变量类型：判断变量类型用typeof 1,字符串：string 2,数字number（包含NaN） 3,布尔值：boolean 4,未定义:undefined(1访问一个不存在的属性2变量定义未赋值） 5函数：function 6,对象：Object 数据类型转换：parseInt();parseFloat();Number(); *Number(‘12.5abc’)&#x3D;&gt;NaN parseInt(‘12.5abc’)&#x3D;&gt;12.5 运算符：1,算数运算符：+,-,,&#x2F;,%2,赋值运算符：&#x3D;，+&#x3D;，-&#x3D;，&#x3D;，&#x2F;&#x3D;,%&#x3D;3,比较运算 &#x3D;&#x3D; &gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;​ &#x3D;&#x3D;相等 ！&#x3D;不等于​ &#x3D;&#x3D;&#x3D;相等 ！&#x3D;&#x3D;不等于逻辑运算：||或 &amp;&amp;与 ！取反 流程控制if 1，if(条件){条件满足就走语句一}else{条件不满足就走语句二}简写：三目：条件？语句一：语句二；2，if(条件){语句； }简写：条件&amp;&amp;语句；3，if(条件一){语句一}else if(条件二){语句二}else{语句三}####switchswitch(条件){ 12345678case 条件1： 语句一；break；case 条件2： 语句二 break；default: 默认语句 } break:中断整个程序，不再执行continue：中断此次程序，继续下一次程序 判断真假:真：非零数字，非空字符串，true，非空对象； 假：数字0，NaN，空字符串，false，undefined，null； 获取非行间样式：1234567891011121314window.onload=function()&#123; var oBox=document.getElementById(&#x27;box&#x27;); oBox.onclick=function()&#123; //getComputedStyle(obj,false);高版本 //obj.currentStyle；ie系列 //alert(getComputedStyle(oBox,false));在ie8直接报错 alert(oBox.currentStyle);//在chrome和ff是undefined if(oBox.currentStyle)&#123; alert(oBox.currentStyle.width); &#125;else&#123; alert(getComputedStyle(oBox,false).width); &#125; &#125;&#125; eval():可将字符串转化成js可执行代码。很强大，容易造成eval注入问题 定时器：连续不断执行：var timer &#x3D; setInterval(函数，时间) 清空定时器：clearInterval(timer); 只执行一次：setTimeout(函数，时间) 时间对象：1234567891011121314var oDate=new Date();var iY=oDate.getFullYear();var iMon=oDate.getMonth()+1;var iD=oDate.getDate();var iWeek=oDate.getDay();var iH=oDate.getHours();var iM=oDate.getMinutes();var iS=oDate.getSeconds();//设置时间var oDate=new Date();oDate.setFullYear(年，月，日)oDate.setHours(时，分，秒，毫秒)//时间戳var time=oDate.getTime(); 封闭空间解决变量名冲突；解决了i的问题；（循环里加事件，事件里的i不好使；循环里加定时器，i也不好使） eg： 123(function(a)&#123; alert(a); &#125;)(12); 设置样式：1）用with语句： 12345with(oBox.style)&#123; width=&#x27;400px&#x27;, height=&#x27;400px&#x27;, background=&#x27;red&#x27;&#125; 2）cssText:批量设置样式 1oBox.style.cssText=&#x27;width:400px; height:400px; background:red&#x27;; 3）setStyle封装函数： 123function setStyle(obj,name,value)&#123; obj.style[name]=value;&#125; ####字符串1，str.charAt(下标) 获取字符串中的某一项2，str.indexOf(‘小字符串’) 获取某个小字符串在字符串中出现的位置 1）从左往右开始找，找到一个就不继续往下找了 2）区分大小写 3)如果没有找到，就返回-1eg： 123456//获取浏览器信息，通过indexOf判断里面有没有MSIE 10.0，如果等于-1，代表没有if(window.navigator.userAgent.indexOf(&#x27;MSIE 10.0&#x27;)!=-1)&#123; alert(&#x27;ie10&#x27;);&#125;else&#123; alert(&#x27;不是ie10&#x27;);&#125; 3，str.lastIndexOf（） 1）从右往左找 2）区分大小写 3）如果没找到就返回-14，str.toLowerCase()转小写5，str.toUpperCase（）转大写&#96;6，str.substring(起始位置下标，结束位置下标) 截取字符串 （不包括结束位置）7，str.startsWith(小字符串)8，str.endsWith(小字符串 )9，str.split(切割方式)切割字符串，把字符串转化成数组 数组转字符串arr.join(切割方式)#####字符串比较：1，字符串数字​ a)两个都是数字字符串类型，一位一位进行比较​ b)其中有一个是数字类型，会做隐式类型转化，转化成数字进行比较2，单词 字典序3，汉字没规律​ unicode 数组：创建数组： var arr&#x3D;[]; var arr &#x3D; new Array();#####数组函数：arr.push() 往数组后面添东西，会返回新的数组的长度arr.unshift() 往数组前面添东西，会返回新的数组的长度arr.pop() 从数组后面删除，会返回被删掉的数据arr.shift() 从前面删除，会返回被删掉的数据arr.splice(开始位置,删除长度,元素1,元素2)arr.reverse()翻转arr.sort() 排序arr1.concat(arr2) 数组合并arr.join()将数组转化成字符串 ####数学方法：Math.random()随机数0-1，不包括1Math.ceil()向上取整Math.floor（）向下取整Math.round()四舍五入Math.abs()绝对值Math.max()取最大值Math.min()取最小值Math.sqrt()开平方Math.pow(n，m)n的m次方","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"浅谈Responsive设计","date":"2017-01-11T14:16:46.000Z","path":"2017/01/11/浅谈Responsive设计/","text":"这两天一直在看CSS3相关的东西，提到CSS3有个很重要的特性就是Media Queries,说到Media Queries,到头来还是网页的响应式开发（Responsive设计简单的称为RWD）。 说到响应式开发，自己第一想到的就是这个带有‘栅格系统’的Bootstrap。它可以让你的网站在不同设备中展现不同的风格，版面不会因为屏幕大小变化而乱掉。说俗一点就是‘有求必应’。就这先前Bootstrap的使用经验，结合理论在这里笔记总结一下。 响应式设计需要满足以下三个条件： 网站必须建立灵活的网格基础； 引用到网站的图片必须是可伸缩的； 不同的显示风格，需要在Media Queries上写不同的样式。 ###响应式设计相关术语1.流体网络流体网格是一个简单的网格系统，这种网格设计参考了流体设计中的网格系统，将每个网格格子使用百分比单位来控制网格大小。这种网格系统最大的好处是让你的网格大小随时根据屏幕尺寸大小做出相对应的比例缩放。2.弹性图片弹性图片指的是不给图片设置固定尺寸，而是根据流体网格进行缩放，用于适应各种网格的尺寸。而实现方法是比较简单，一句代码就能搞定的事情。 1img &#123;max-width:100%;&#125; (在ie8中存在问题&#x3D;。&#x3D;)3.媒体查询就是开头说到的CSS3强大的新扩展吧。使用这个属性可以让你的设计根据用户终端设备适配对应的样式。这也是响应式设计中最为关键的。可以说Responsive设计离开了Medial Queries就失去了他生存的意义。4.主要断点对于Responsive设计中是一个很重要的一部分。简单的描述就是，设备宽度的临界点。在Media Queries中，其中媒体特性“min-width”和“max-width”对应的属性值就是响应式设计中的断点值。简单点说，就是使用主要断点和次要断点，创建媒体查询的条件。而每个断点会对应调用一个样式文件（或者样式代码）上图的style.css样式文件运用在Web页面中，但这个样式文件包括了所有风格的样式代码，也就是说所有设备下显示的风格都通过这个样式文件下载下来。 ###响应式设计—–meta标签最后还有一个不可或缺的东东，那就是meta标签。eg： 1&lt;meta name=”viewport” content=”” /&gt; 其中content属性用来处理可视区域。属性值这块就不一一列举了。在实际项目中，为了让Responsive设计在智能设备中能显示正常，也就是浏览Web页面适应屏幕的大小，显示在屏幕上，可以通过这个可视区域的meta标签进行重置，告诉他使用设备的宽度为视图的宽度，也就是说禁止其默认的自适应页面的效果，具体设置如下： 1&lt;meta name=”viewport” content=”width=device-width,initial-scale=1.0” /&gt; ###不同设备的分辨率设置在网上找的以后应该有用！1.1024px显屏 123@media screen and (max-width : 1024px) &#123; /* 样式写在这里 */ &#125; 2.800px显屏 123@media screen and (max-width : 800px) &#123; /* 样式写在这里 */ &#125; 3.640px显屏 123@media screen and (max-width : 640px) &#123; /* 样式写在这*/ &#125; 4.iPad横板显屏 123@media screen and (max-device-width: 1024px) and (orientation: landscape) &#123; /* 样式写在这 */ &#125; 5.iPad竖板显屏 123@media screen and (max-device-width: 768px) and (orientation: portrait) &#123; /* 样式写在这 */ &#125; 6.iPhone 和 Smartphones 123@media screen and (min-device-width: 320px) and (min-device-width: 480px) &#123; /* 样式写在这 */ &#125; 结尾测试一下新blog的图片功能好不好使。&#x3D;。&#x3D;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"响应式","slug":"响应式","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"SASS基础语法总结","date":"2017-01-04T15:51:32.000Z","path":"2017/01/05/sass基础语法总结/","text":"SASSCSS预处理器。一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大。 语法1.变量 $开头紧跟变量名，变量名值以：分隔，！表示默认值 。$blue : #1875e7; 1234$blue : #1875e7; div &#123;color : $blue;&#125; 2.导入@import； 导入其他sass文件。（优于css的@import） 1@import &quot;path/filename.scss&quot;; 3.计算功能； 允许在代码中使用算式 12345 body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%; &#125; 4.嵌套； 可以在代码中进行嵌套（自己尝试sass之后，有了嵌套这个语法，可以省去起名的麻烦，很方便的功能&#x3D;。&#x3D;） 12345 div &#123; hi &#123; color:red; &#125; &#125; 在嵌套里可以使用&amp;引用父级元素。 12345678910a&#123; &amp;:hover&#123; color:#fff; &#125; &amp;:after&#123; content:&#x27;&#x27;; clear:both; display:block; &#125; &#125; 5.mixin(宏)； 类似其他语言的函数。可以重用代码块。使用@mixin命令，定义一个代码块。 123 @mixin fl &#123; float: left; &#125; 使用@include命令，调用这个mixin。 123 div &#123; @include fl; &#125; 6.继承 1234//sass .class1&#123; border: 1px solid #ddd; &#125; .class2&#123; @extend .class1; font-size:120%; &#125; //编译后css .class1,.class2&#123; border: 1px solid #ddd; &#125; .class2&#123; font-size:120%; &#125; 7,IF 1234567p&#123; @if 12+2==14 &#123; color:#fff; &#125;@else&#123; color:#000; &#125; &#125; 8,循环 for循环 12345@for $i form 1 to 10&#123; .border-#&#123;$i&#125;&#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; while循环 1234567$i:6; @while $i&gt;0&#123; .item-#&#123;$i&#125;&#123; width:4px * $i; &#125; $i: $i - 2; &#125; each命令 123456@each $member in a,b,c,d&#123; .#&#123;$member&#125;&#123; background-image: url(&quot;img/#&#123;$member&#125;.jpg&quot;); &#125; &#125; ###总结差不多常用的就这些，个人觉得有了嵌套，可以让代码更有逻辑，敲起来顺手很多。在开发中比较重要的就是@mixin的使用和@extend的使用。可以提高代码的复用率。就这样。一个用sass写的小DEMO ####github上第一篇blog，纪念一下！。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"SASS","slug":"SASS","permalink":"http://yoursite.com/tags/SASS/"}]}]